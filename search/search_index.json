{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-the-official-documentation-of-cad-sketcher","title":"Welcome to the official documentation of CAD Sketcher","text":""},{"location":"#what-is-cad-sketcher","title":"What is CAD Sketcher?","text":"<p>CAD Sketcher is a constraint-based sketcher extension for Blender that allows to create precise 2d shapes by defining a set of geometric constraints like tangent, distance, angle, equal and more. Sketches stay editable and support a fully non-destructive workflow.</p>"},{"location":"#overview","title":"Overview","text":"<p>CAD Sketcher integrates the solver of Solvespace and closely follows its design. Therefore the Solvespace Documentation is generally also relevant.</p> <p>In order to have a parametric representation of a geometric system where curves are independent of resolution, CAD Sketcher introduces a set of Entities.</p> <p>Those Entities can be both in 2d and 3d. CAD Sketcher isn't strictly limited to but mainly focuses on 2d entities. In order to group a set of 2d entities we use Sketches.</p> <p>The final position and dimensions of a drawn shape is defined by Constraints.</p> <p>In order to have entities follow the defined constraints, a Solver is needed.</p> <p>To further process the resulting geometry CAD Sketcher uses Converters to get native Blender geometry types which then allow further modifications with native tools.</p>"},{"location":"#links","title":"Links","text":"<ul> <li>Releases - Get the extension</li> <li>Bug Report - Report a bug</li> <li>Github Issues - Suggest features and follow the development</li> <li>Discord - A place for discussions</li> <li>Contribute - Looking to help out in some way?</li> </ul>"},{"location":"advanced/","title":"Advanced","text":""},{"location":"advanced/#report-a-bug","title":"Report a Bug","text":"<p>Whenever encountering a bug follow these steps:</p> <ul> <li>Check if the bug is already reported on github</li> <li>Try to reliably reproduce the bug and simplify the steps to reproduce</li> <li>Collect the extension logs</li> <li>In case of a crash also collect blender's crash report</li> <li>Post the bug on github</li> </ul>"},{"location":"advanced/#console-output","title":"Console Output","text":"<p>Blender doesn't print system output in its info editor but only in the system terminal. Follow the guide below to access blender's system console.</p> Linux / MacWindows <p>To see the system output blender has to be started from the terminal</p> <ul> <li>Open a console by pressing Ctrl+Alt+T</li> <li>Enter \"blender\" or the path to a specific blender version</li> </ul> <ul> <li>In blender click Window-&gt;Toggle System Console</li> </ul>"},{"location":"advanced/#console-output-vscode-dependency","title":"Console Output VScode dependency","text":"<p>CAD sketcher for debugging purposes depends on the library debugpy when debugging is done through VSCode. Installing this library with <code>$pip install</code>  will further mean that the window in VSCode will need to be reloaded using  <code>command Palette &gt; Reload window</code> .</p>"},{"location":"advanced/#access-logs","title":"Access Logs","text":"<p>Logs are helpful for debugging. Note that there are logs from the extension as well as from blender itself.</p>"},{"location":"advanced/#extension-logs","title":"Extension Logs","text":"<p>The extension logs information to the system console and to the system's temporary folder. The filepath to this folder will be printed to the console whenever the extension gets registered.</p> <p>CAD_Sketcher:{INFO}: Logging into: /tmp/bl_ext.user_default.CAD_Sketcher.log</p>"},{"location":"advanced/#blender-crash-log","title":"Blender Crash Log","text":"<p>When blender crashes it writes a crash report file, see: crash report.</p>"},{"location":"advanced/#contribute","title":"Contribute","text":"<p>Help is always welcome. There are multiple ways to support the project.</p>"},{"location":"advanced/#testing","title":"Testing","text":"<p>Just grab the latest version, play around, provide feedback and redo!</p> <p>If you've made code changes to the extension and want to test those, zip the project folder and install it through <code>Blender Preferences &gt; Add-ons &gt; Install</code>.</p>"},{"location":"advanced/#documentation","title":"Documentation","text":"<p>Documentation is generated from the source repository with MkDocs. In order to contribute either post a pull request with your changes on github or ask on discord for commit access.</p> <p>Note: There are github workflows which will automatically test and build the documentation after changes are made.</p>"},{"location":"advanced/#development","title":"Development","text":"<p>If you'd like to help with development simply submit pull requests or reach out on discord, or github.</p> <p>Take a look at the existing code documentation, this isn't complete yet, if you are missing some specific information feel free to ask in the discord's contribute channel.</p> <p>Have a look at the open issues on github. Some of them are marked with the good first issue tag. Also take a look at the roadmap to see where the priority currently lies.</p> <p>Code Style</p> <p>The project uses the Black Formatter, make sure to enable it in your code editor before pushing pull requests.</p>"},{"location":"code_docs/","title":"Code Documentation","text":""},{"location":"code_docs/#core","title":"Core","text":"<p>At the base of the extension there's the properties structure. The model subpackage defines a set of blender PropertyGroups. This is needed so that values are stored to disk on file save. These PropertyGroups have to be registered and then be pointed to from somewhere by a PointerProperty.</p> <p>Additionally to pure properties PropertyGroups can also hold methods and attributes, the extension makes heavy use of that as it leads to a convenient way of working with the data.</p> <p>The root of the extension's data structure is SketcherProps which is registered on blender's Scene type and can therefore be accessed as follows: <pre><code>bpy.context.scene.sketcher\n</code></pre></p> <p>From there the structure looks as follows:</p> <p>sketcher   - entities     - points3D (CollectionProperty of 3D Points)     - lines3D (CollectionProperty of 3D Lines)     - sketches     - ...</p> <ul> <li>constraints<ul> <li>coincident (CollectionProperty of coincident constraints)</li> <li>equal</li> <li>...</li> </ul> </li> </ul> <p>Note: The nesting of PropertyGroups is done by defining PointerProperties inside of a PropertyGroup.</p>"},{"location":"code_docs/#entities","title":"Entities","text":"<p>Entities always inherit from the SlvsGenericEntity class which implements the basic properties (like properties to store if an entity is visible, construction, origin etc.) and logic (like the draw method which draws itself based on its geometry batch) entities have.</p>"},{"location":"code_docs/#index-system","title":"Index system","text":"<p>As an entity can depend on other entities there has to be a way to point to an entity. This is done by storing an unique index on each entity (entity.slvs_index) which is set when an entity is created through its \"add_*\" method on the SlvsEntities class.</p> <p>Pointing to an entity is done by storing the entity's index in a IntProperty, the entity itself can then be looked up by: <pre><code>entity = bpy.context.scene.sketcher.entities.get(index)\n</code></pre></p> <p>For convenience there's the slvs_entity_pointer function which registers the IntProperty with a \"_i\" prefix and adds getter/setter methods to directly get the entity without having to deal with the index itself.</p>"},{"location":"code_docs/#drawing","title":"Drawing","text":"<p>Entities are drawn in the viewport by utilizing blenders GPU Module. Every entity type has an update function which is responsible for creating the geometry batch that is used for drawing. As this can be expensive to compute the batches are stored based on the entity's index in global_data.batches. There's an initial tagging system in place to tag entities as dirty however this is currently still disabled by default.</p> <p>NOTE: In order to draw anything a draw handler has to be registered on the viewport type. This usually happens from an operator that the user invokes. As this is rather bad UX the extension registers the handler when the extension is registered. More precisely, as the the context at register time is limited, a Application Timer is used to register the draw handler shortly after the extension has been registered.</p>"},{"location":"code_docs/#selection","title":"Selection","text":"<p>Entity selection is done by simply drawing entities a second time in an Offscreen Texture. The color however is used to identify the entity. The two functions index_to_rgb() and rgb_to_index() inside functions.py are used to convert between the entity's \"slvs_index\" and the color value that is written to the texture.</p> <p>This concept is explained here.</p> <p>NOTE: There's the \"Write Selection Texture\" operator in the debug panel which can be used to write the current selection texture to an image data-block in order to inspect it.</p>"},{"location":"code_docs/#preselection","title":"Preselection","text":"<p>The extension makes great use of preselection highlighting. To achieve that the VIEW3D_GT_slvs_preselection gizmo is used which looks up the currently hovered pixel and writes the index to global_data.hover whenever the \"test_select\" method is called.</p> <p>NOTE: The test_select method of gizmos is used as it receives the cursor location and is called whenever the cursor moves.</p>"},{"location":"code_docs/#constraints","title":"Constraints","text":"<p>Constraints always inherit from the GenericConstraint class which implements the basic properties (like properties to store if a constraint is visible or has failed to solve etc.) and some basic logic that constraints have.</p> <p>Unlike entities the constraints are not implemented completely from scratch but rather make use of the Gizmo API to display themselves and handle other interactions like selection.</p>"},{"location":"code_docs/#interaction","title":"Interaction","text":"<p>There's a set of operators defined in operators.py which are used to create the interaction between the user and the extension. Note that the extension also has to define operators for basic interactions like selection or calling the context menu due to the fact that entities are implemented from scratch.</p> <p>Most of the viewport operators inherit from the StatefulOperator class which is a framework to allow defining complex tools in a declarative fashion. Besides the base class itself which implements logic for native blender types there's also the GenericEntityOp which adds support for extension specific types. Have a look at the interaction chapter in the docs.</p> <p>The extension also makes heavy use of workspacetools. Note that they depend on some functionality defined in the StatefulOperator class to display the correct description and get the tools shortcuts.</p> <p>NOTE: Tools that need to be able to select entities have to use the preselection gizmo in order to get updated selection.</p>"},{"location":"code_docs/#solver","title":"Solver","text":"<p>The extension uses the Python Binding of Solvespace. As the solver module isn't well documented it's best to inspect it through the an interactive python interpreter. This can be done inside blender's python console when the solver module has been installed, something like this: <pre><code>import slvs\nsys = slvs.System()\n</code></pre></p> <p>On the system object you'll find all the methods to add entities and constraints. You can use the inspect module to get more info like the signature of a function: <pre><code>import inspect\ninspect.signature(sys.addEqual)\n</code></pre></p> <p>The solver data isn't persistent, so whenever the solver is triggered it will create a new \"py_slvs.slvs.System\" object.Then the solver will go through the relevant entities and call their create_slvs_data method and pass the system object to it. Same applies to the constraints.</p> <p>The create_slvs_data has to return the solver handles of the elements it adds to the solver. This is later used to check which constraints have failed to solve.</p> <p>When the solver was successful it will again go through all the entities and call their update_from_slvs methods to update the blender data from the solver system.</p>"},{"location":"code_docs/#converter","title":"Converter","text":"<p>Currently there is only one native converter implemented, namely the BezierConverter defined in converters.py. When converting to mesh the target bezier object is simply converted again with blenders to_mesh function. This is a design choice to workaround the problem of finding the area to fill for a given shape.</p> <p>As a bezier spline is defined by a list of bezier control-points entities we have to create a list of connected entities. This is done by the BezierConverter.walker() method. After that we cam simply loop through these connected entities and call their to_bezier() method.</p>"},{"location":"code_docs/#faq","title":"FAQ","text":""},{"location":"code_docs/#what-happens-when-a-button-is-pressed","title":"What happens when a button is pressed?","text":"<p>In blender every user interaction happens through an operator. You can enable python tooltips to find the corresponding operator from a button. Check blenders API Docs for more information.</p>"},{"location":"code_docs/#gotchas","title":"Gotcha's","text":""},{"location":"code_docs/#entity-pointers-loose-their-assigned-values","title":"Entity pointers loose their assigned values","text":"<p>AttributeError: 'NoneType' object has no attribute \"slvs_index\"</p> <p>As described here data might not directly update after edit. This usually isn't a problem for interactive operators however it can be the case with operators, scripts or tests which add multiple entities/constraints at once. This can be solved by calling context.view_layer.update() before adding an element that depends on an element that was just created. Just be aware that this might have a negative performance impact. A better approach is to use the \"index_reference\" mode of the entity \"add_\" methods. If set to True the method will return the index of the entity rather than the object itself. All \"add_\" methods will allow passing entities by index, additionally they also accept passing parameters.</p> <pre><code>entities = context.scene.sketcher.entities\n\np1 = entities.add_point_3d((0, 0, 0), index_reference=True)\np2 = entities.add_point_3d((1, 1, 0), index_reference=True)\nline = entities.add_line_3d(p1, p2, construction=True, index_reference=True)\n\nassert type(p1) == int\n</code></pre>"},{"location":"code_docs/#properties-update-callbacks","title":"Propertie's update callbacks","text":"<p>Some properties of entities or constraints have an update callback assigned which will be triggered whenever the property is changed, it's mainly used to trigger the solver or update the view. Example of this are the point entity's location property or the value property of dimensional constraints which will both trigger the solver when the property is changed. This behaiviour is not always welcome. When writing a tool it's almost always better to avoid triggering these callbacks and manually solving the system, updating the view etc.</p> <p>To avoid it, either set all properties in the \"add_*\" methods or change the value of properties like so:</p> <p>entity[\"some_prop\"] = value</p>"},{"location":"constraints/","title":"Constraints","text":"<p>Constraints are used to restrict the movement of entities and define their final locations. A constraint can usually be created between different entity types, check the corresponding operator's tooltip to find out what's supported.</p>"},{"location":"constraints/#active","title":"Active","text":"<p>A constraint is considered to be active when the sketch it belongs to is set as the active sketch or, for constraints that don't belong to a sketch, when no sketch is active.</p>"},{"location":"constraints/#failure","title":"Failure","text":"<p>Whenever the solver fails to find a solution for the given system it will try to mark constraints that are causing the failure. Those constraints will be colored red, additionally the failed sketch will be marked.</p>"},{"location":"constraints/#types","title":"Types","text":"<p>Constraint types follow the implementation of solvespace.</p>"},{"location":"constraints/#geometric-constraints","title":"Geometric Constraints","text":"<p>               Bases: <code>GenericConstraint</code>, <code>PropertyGroup</code></p> <p>Forces two points to be coincident, or a point to lie on a curve, or a point to lie on a plane.</p> <p>The point-coincident constraint is available in both 3d and projected versions. The 3d point-coincident constraint restricts three degrees of freedom; the projected version restricts only two. If two points are drawn in a workplane, and then constrained coincident in 3d, then an error will result\u2013they are already coincident in one dimension (the dimension normal to the plane), so the third constraint equation is redundant.</p> Source code in <code>model/coincident.py</code> <pre><code>class SlvsCoincident(GenericConstraint, PropertyGroup):\n    \"\"\"Forces two points to be coincident,\n    or a point to lie on a curve, or a point to lie on a plane.\n\n    The point-coincident constraint is available in both 3d and projected versions.\n    The 3d point-coincident constraint restricts three degrees of freedom;\n    the projected version restricts only two. If two points are drawn in a workplane,\n    and then constrained coincident in 3d, then an error will result\u2013they are already\n    coincident in one dimension (the dimension normal to the plane),\n    so the third constraint equation is redundant.\n    \"\"\"\n\n    type = \"COINCIDENT\"\n    label = \"Coincident\"\n    signature = (POINT, (*POINT, *LINE, SlvsWorkplane, SlvsCircle, SlvsArc))\n    # NOTE: Coincident between 3dPoint and Workplane currently doesn't seem to work\n\n    def needs_wp(self):\n        if isinstance(self.entity2, SlvsWorkplane):\n            return WpReq.FREE\n        return WpReq.OPTIONAL\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        return make_coincident(\n            solvesys, self.entity1.py_data, self.entity2, self.get_workplane(), group\n        )\n\n    def placements(self):\n        return (self.entity1,)\n</code></pre> <p>               Bases: <code>GenericConstraint</code>, <code>PropertyGroup</code></p> <p>Forces a line segment to be vertical. It applies in 2D Space only because the meaning of horizontal or vertical is defined by the workplane.</p> Source code in <code>model/vertical.py</code> <pre><code>class SlvsVertical(GenericConstraint, PropertyGroup):\n    \"\"\"Forces a line segment to be vertical. It applies in 2D Space only because\n    the meaning of horizontal or vertical is defined by the workplane.\n    \"\"\"\n\n    type = \"VERTICAL\"\n    label = \"Vertical\"\n    signature = ((SlvsLine2D, SlvsPoint2D), (SlvsPoint2D,))\n\n    @classmethod\n    def get_types(cls, index, entities):\n        if index == 1:\n            # return None if first entity is line\n            if entities[0] and entities[0].is_line():\n                return None\n\n        return cls.signature[index]\n\n    def needs_wp(self):\n        return WpReq.NOT_FREE\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        wp = self.get_workplane()\n        kwargs = {}\n\n        if self.entity1.is_point():\n            kwargs['entityB'] = self.entity2.py_data\n\n        return solvesys.vertical(group, self.entity1.py_data, wp, **kwargs)\n\n    def placements(self):\n        return (self.entity1,)\n</code></pre> <p>               Bases: <code>GenericConstraint</code>, <code>PropertyGroup</code></p> <p>Forces a line segment to be horizontal. It applies in 2D Space only because the meaning of horizontal or vertical is defined by the workplane.</p> Source code in <code>model/horizontal.py</code> <pre><code>class SlvsHorizontal(GenericConstraint, PropertyGroup):\n    \"\"\"Forces a line segment to be horizontal. It applies in 2D Space only because\n    the meaning of horizontal or vertical is defined by the workplane.\n    \"\"\"\n\n    type = \"HORIZONTAL\"\n    label = \"Horizontal\"\n    signature = ((SlvsLine2D, SlvsPoint2D), (SlvsPoint2D,))\n\n    @classmethod\n    def get_types(cls, index, entities):\n        if index == 1:\n            # return None if first entity is line\n            if entities[0] and entities[0].is_line():\n                return None\n\n        return cls.signature[index]\n\n    def needs_wp(self):\n        return WpReq.NOT_FREE\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        wp = self.get_workplane()\n\n        kwargs = {}\n        if self.entity1.is_point():\n            kwargs['entityB'] = self.entity2.py_data\n\n        return solvesys.horizontal(group, self.entity1.py_data, wp, **kwargs)\n\n    def placements(self):\n        return (self.entity1,)\n</code></pre> <p>Note: It\u2019s good to use horizontal and vertical constraints whenever possible. These constraints are very simple to solve, and will not lead to convergence problems. Whenever possible, define the workplanes so that lines are horizontal and vertical within those workplanes.</p> <p>               Bases: <code>GenericConstraint</code>, <code>PropertyGroup</code></p> <p>Forces two lines to be parallel. Applies only in 2D.</p> Source code in <code>model/parallel.py</code> <pre><code>class SlvsParallel(GenericConstraint, PropertyGroup):\n    \"\"\"Forces two lines to be parallel. Applies only in 2D.\"\"\"\n\n    type = \"PARALLEL\"\n    label = \"Parallel\"\n    signature = ((SlvsLine2D,), (SlvsLine2D,))\n\n    def needs_wp(self):\n        return WpReq.NOT_FREE\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        wp = self.get_workplane()\n        kwargs = {}\n        if wp:\n            kwargs['workplane'] = wp\n\n        return solvesys.parallel(\n            group,\n            self.entity1.py_data,\n            self.entity2.py_data,\n            **kwargs,\n        )\n\n    def placements(self):\n        return (self.entity1, self.entity2)\n</code></pre> <p>               Bases: <code>GenericConstraint</code>, <code>PropertyGroup</code></p> <p>Forces two lines to be perpendicular, applies only in 2D. This constraint is equivalent to an angle constraint for ninety degrees.</p> Source code in <code>model/perpendicular.py</code> <pre><code>class SlvsPerpendicular(GenericConstraint, PropertyGroup):\n    \"\"\"Forces two lines to be perpendicular, applies only in 2D. This constraint\n    is equivalent to an angle constraint for ninety degrees.\n    \"\"\"\n\n    type = \"PERPENDICULAR\"\n    label = \"Perpendicular\"\n    signature = ((SlvsLine2D,), (SlvsLine2D,))\n\n    def needs_wp(self):\n        return WpReq.NOT_FREE\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        wp = self.get_workplane()\n        kwargs = {}\n        if wp:\n            kwargs['workplane'] = wp\n\n        return solvesys.perpendicular(\n            group,\n            self.entity1.py_data,\n            self.entity2.py_data,\n            **kwargs,\n        )\n\n    def placements(self):\n        point = get_connection_point(self.entity1, self.entity2)\n        if point:\n            return (point,)\n        return (self.entity1, self.entity2)\n</code></pre> <p>               Bases: <code>GenericConstraint</code>, <code>PropertyGroup</code></p> <p>Forces two lengths, or radiuses to be equal.</p> <p>If a line and an arc of a circle are selected, then the length of the line is forced equal to the length (not the radius) of the arc.</p> Source code in <code>model/equal.py</code> <pre><code>class SlvsEqual(GenericConstraint, PropertyGroup):\n    \"\"\"Forces two lengths, or radiuses to be equal.\n\n    If a line and an arc of a circle are selected, then the length of the line is\n    forced equal to the length (not the radius) of the arc.\n    \"\"\"\n\n    type = \"EQUAL\"\n    label = \"Equal\"\n    signature = (line_arc_circle, line_arc_circle)\n\n    @classmethod\n    def get_types(cls, index, entities):\n        e = entities[1] if index == 0 else entities[0]\n        if e:\n            if type(e) in (SlvsLine2D, SlvsArc):\n                return (SlvsLine2D, SlvsArc)\n            elif type(e) == SlvsCircle:\n                return CURVE\n            return (type(e),)\n        return cls.signature[index]\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        e1, e2 = self.entity1, self.entity2\n\n        wp = self.get_workplane()\n        kwargs = {}\n        if wp:\n            kwargs[\"workplane\"] = wp\n\n        return solvesys.equal(group, e1.py_data, e2.py_data, **kwargs)\n\n    def placements(self):\n        return (self.entity1, self.entity2)\n</code></pre> <p>               Bases: <code>GenericConstraint</code>, <code>PropertyGroup</code></p> <p>Forces two curves (arc/circle) or a curve and a line to be tangent.</p> Source code in <code>model/tangent.py</code> <pre><code>class SlvsTangent(GenericConstraint, PropertyGroup):\n    \"\"\"Forces two curves (arc/circle) or a curve and a line to be tangent.\"\"\"\n\n    type = \"TANGENT\"\n    label = \"Tangent\"\n    signature = (CURVE, (SlvsLine2D, *CURVE))\n\n    def needs_wp(self):\n        return WpReq.NOT_FREE\n\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        e1, e2 = self.entity1, self.entity2\n        wp = self.get_workplane()\n\n        CIRCLE_ARC = (SlvsCircle, SlvsArc)\n        if type(e1) in CIRCLE_ARC and e2.is_line():\n            orig = e2.p1.co\n            coords = (e1.ct.co - orig).project(e2.p2.co - orig) + orig\n            p = solvesys.add_point_2d(group, *coords, wp)\n            line = solvesys.add_line_2d(group, e1.ct.py_data, p, wp)\n            return (\n                make_coincident(solvesys, p, e1, wp, group),\n                make_coincident(solvesys, p, e2, wp, group),\n                solvesys.perpendicular(group, e2.py_data, line, workplane=wp),\n            )\n        elif type(e1) in CIRCLE_ARC and type(e2) in CIRCLE_ARC:\n            coords = (e1.ct.co + e2.ct.co) / 2\n            p = solvesys.add_point_2d(group, *coords, wp)\n            line = solvesys.add_line_2d(group, e1.ct.py_data, e2.ct.py_data, wp)\n\n            return (\n                make_coincident(solvesys, p, e1, wp, group),\n                make_coincident(solvesys, p, e2, wp, group),\n                solvesys.coincident(group, p, line, wp)\n            )\n\n        return solvesys.tangent(group, e2.py_data, e1.py_data, wp)\n\n\n    def placements(self):\n        point = get_connection_point(self.entity1, self.entity2)\n        if point is None:\n            return (self.entity1, self.entity2)\n        return (point,)\n</code></pre> <p>               Bases: <code>GenericConstraint</code>, <code>PropertyGroup</code></p> <p>Forces a point to lie on the midpoint of a line.</p> Source code in <code>model/midpoint.py</code> <pre><code>class SlvsMidpoint(GenericConstraint, PropertyGroup):\n    \"\"\"Forces a point to lie on the midpoint of a line.\"\"\"\n\n    type = \"MIDPOINT\"\n    label = \"Midpoint\"\n    signature = (POINT, LINE)\n\n    def needs_wp(self):\n        return WpReq.NOT_FREE\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        wp = self.get_workplane()\n        kwargs = {}\n        if wp:\n            kwargs[\"workplane\"] = wp\n\n        return solvesys.midpoint(\n            group,\n            self.entity1.py_data,\n            self.entity2.py_data,\n            **kwargs,\n        )\n\n    def placements(self):\n        return (self.entity2,)\n</code></pre> <p>               Bases: <code>DimensionalConstraint</code>, <code>PropertyGroup</code></p> <p>Defines the ratio between the lengths of two line segments.</p> <p>The order matters; the ratio is defined as length of entity1 : length of entity2.</p> Source code in <code>model/ratio.py</code> <pre><code>class SlvsRatio(DimensionalConstraint, PropertyGroup):\n    \"\"\"Defines the ratio between the lengths of two line segments.\n\n    The order matters; the ratio is defined as length of entity1 : length of entity2.\n    \"\"\"\n\n    type = \"RATIO\"\n    label = \"Ratio\"\n\n    value: FloatProperty(\n        name=label,\n        subtype=\"UNSIGNED\",\n        update=update_system_cb,\n        min=0.0,\n    )\n\n    signature = (\n        LINE,\n        LINE,\n    )\n\n    def needs_wp(self):\n        if isinstance(self.entity1, SlvsLine2D) or isinstance(self.entity2, SlvsLine2D):\n            return WpReq.NOT_FREE\n        return WpReq.FREE\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        e1, e2 = self.entity1, self.entity2\n\n        wp = self.get_workplane()\n        kwargs = {}\n        if wp:\n            kwargs['workplane'] = wp\n\n        return solvesys.ratio(\n            group,\n            e1.py_data,\n            e2.py_data,\n            self.value,\n            **kwargs,\n        )\n\n    def init_props(self, **kwargs):\n        line1, line2 = self.entity1, self.entity2\n        if line2.length == 0.0:\n            return {\"value\": 0.0}\n\n        value = line1.length / line2.length\n        return {\"value\": value}\n\n    def placements(self):\n        return (self.entity1, self.entity2)\n</code></pre>"},{"location":"constraints/#dimensional-constraints","title":"Dimensional Constraints","text":"<p>               Bases: <code>DimensionalConstraint</code>, <code>PropertyGroup</code></p> <p>Sets the distance between a point and some other entity (point/line/Workplane).</p> Source code in <code>model/distance.py</code> <pre><code>class SlvsDistance(DimensionalConstraint, PropertyGroup):\n    \"\"\"Sets the distance between a point and some other entity (point/line/Workplane).\"\"\"\n\n    def _set_value_force(self, value):\n        DimensionalConstraint._set_value_force(self, abs(value))\n\n    def _set_align(self, value: int):\n        alignment = bpyEnum(align_items, value).identifier\n        distance = _get_aligned_distance(self.entity1, self.entity2, alignment)\n        setprop(self, \"align\", value)\n        setprop(self, \"value\", distance)\n\n    def _get_align(self) -&gt; int:\n        return self.get(\"align\", 0)\n\n    label = \"Distance\"\n    value: FloatProperty(\n        name=label,\n        subtype=\"DISTANCE\",\n        unit=\"LENGTH\",\n        precision=6,\n        update=update_system_cb,\n        get=_get_value,\n        set=DimensionalConstraint._set_value,\n    )\n    flip: BoolProperty(name=\"Flip\", update=update_system_cb)\n    align: EnumProperty(\n        name=\"Align\",\n        items=align_items,\n        update=update_system_cb,\n        get=_get_align,\n        set=_set_align,\n    )\n    draw_offset: FloatProperty(name=\"Draw Offset\", default=0.3)\n    draw_outset: FloatProperty(name=\"Draw Outset\", default=0.0)\n    type = \"DISTANCE\"\n    signature = ((*POINT, *LINE, SlvsCircle, SlvsArc), (*POINT, *LINE, SlvsWorkplane))\n    props = (\"value\",)\n\n    @classmethod\n    def get_types(cls, index, entities):\n        e = entities[1] if index == 0 else entities[0]\n\n        if e:\n            if index == 1 and e.is_line():\n                # Allow constraining a single line\n                return None\n            if e.is_3d():\n                return ((SlvsPoint3D,), (SlvsPoint3D, SlvsLine3D, SlvsWorkplane))[index]\n            return (POINT2D, (*POINT2D, SlvsLine2D))[index]\n        return cls.signature[index]\n\n    def needs_wp(self):\n        if isinstance(self.entity2, SlvsWorkplane):\n            return WpReq.FREE\n        return WpReq.OPTIONAL\n\n    def use_flipping(self):\n        # Only use flipping for constraint between point and line/workplane\n        if self.entity1.is_curve():\n            return False\n        return type(self.entity2) in (*LINE, SlvsWorkplane)\n\n    def use_align(self):\n        \"\"\"Returns True if constraint's entities allow distance to be aligned\"\"\"\n        if type(self.entity2) in (*LINE, SlvsWorkplane):\n            return False\n        if self.entity1.is_curve():\n            return False\n        return True\n\n    def is_align(self):\n        \"\"\"Returns True if constraint is aligned\"\"\"\n        return self.use_align() and self.align != \"NONE\"\n\n    def get_value(self):\n        value = self.value\n        if self.use_flipping() and self.flip:\n            return value * -1\n        return value\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        if self.entity1 == self.entity2:\n            raise AttributeError(\"Cannot create constraint between one entity itself\")\n        # TODO: don't allow Distance if Point -&gt; Line if (Point in Line)\n\n        e1, e2 = self.entity1, self.entity2\n        if e1.is_line():\n            e1, e2 = e1.p1, e1.p2\n\n        func = None\n        set_wp = False\n        wp = self.get_workplane()\n        alignment = self.align\n        align = self.is_align()\n        handles = []\n\n        value = self.get_value()\n\n        # circle/arc -&gt; line/point\n        if type(e1) in CURVE:\n            # TODO: make Horizontal and Vertical alignment work\n            if type(e2) in LINE:\n                return solvesys.distance(\n                    group, e1.ct.py_data, e2.py_data, value + e1.radius, wp\n                )\n            else:\n                assert isinstance(e2, SlvsPoint2D)\n                return solvesys.distance(\n                    group, e1.ct.py_data, e2.py_data, value + e1.radius, wp\n                )\n\n        elif type(e2) in LINE:\n            func = solvesys.distance\n            set_wp = True\n        elif isinstance(e2, SlvsWorkplane):\n            func = solvesys.distance\n        elif type(e2) in POINT:\n            if align and all([e.is_2d() for e in (e1, e2)]):\n\n                # Get Point in between\n                p1, p2 = e1.co, e2.co\n                coords = (p2.x, p1.y)\n\n                p = solvesys.add_point_2d(group, *coords, wp)\n\n                handles.append(\n                    solvesys.horizontal(group, p, wp, entityB=e2.py_data)\n                )\n                handles.append(\n                    solvesys.vertical(group, p, wp, entityB=e1.py_data)\n                )\n\n                base_point = e1 if alignment == \"VERTICAL\" else e2\n                handles.append(\n                    solvesys.distance(\n                        group, p, base_point.py_data, value, wp\n                    )\n                )\n                return handles\n            else:\n                func = solvesys.distance\n            set_wp = True\n\n        args = []\n        if set_wp:\n            args.append(self.get_workplane())\n\n        return func(group, e1.py_data, e2.py_data, value, *args)\n\n    def matrix_basis(self):\n        if self.sketch_i == -1 or not self.entity1.is_2d():\n            # TODO: Support distance in 3d\n            return Matrix()\n\n        sketch = self.sketch\n        x_axis = Vector((1, 0))\n        alignment = self.align\n        align = self.is_align()\n        angle = 0\n\n        e1, e2 = self.entity1, self.entity2\n        #   e1       e2\n        #   ----------------\n        #   line     [none]\n        #   point    point\n        #   point    line\n        #   arc      point\n        #   arc      line\n        #   circle   point\n        #   circle   line\n\n        # set p1 and p2\n        if e1.is_curve():\n            # reframe as point-&gt;point and continue\n            centerpoint = e1.ct.co\n            if e2.is_line():\n                p2, _ = intersect_point_line(centerpoint, e2.p1.co, e2.p2.co)\n            else:\n                assert isinstance(e2, SlvsPoint2D)\n                p2 = e2.co\n            if (p2 - centerpoint).length &gt; 0:\n                vec = (p2 - centerpoint) / (p2 - centerpoint).length\n                p1 = centerpoint + (e1.radius * Vector(vec))\n            else:\n                # This is a curve-&gt;line where the centerpoint of the curve is\n                # coincident with the line.  By reassigning p1 to an endpoint\n                # of the line, we avoid p1=p2 errors and the result is\n                # (correctly) an invalid constraint\n                p1 = e2.p1.co\n        elif e1.is_line():\n            # reframe as point-&gt;point and continue\n            e1, e2 = e1.p1, e1.p2\n            p1, p2 = e1.co, e2.co\n        else:\n            assert isinstance(e1, SlvsPoint2D)\n            p1 = e1.co\n\n        if type(e2) in POINT2D:\n            # this includes \"Line Length\" (now point-&gt;point)\n            # and curve -&gt; point\n            p2 = e2.co\n            if not align:\n                v_rotation = p2 - p1\n            else:\n                v_rotation = (\n                    Vector((1.0, 0.0))\n                    if alignment == \"HORIZONTAL\"\n                    else Vector((0.0, 1.0))\n                )\n\n            if v_rotation.length != 0:\n                angle = v_rotation.angle_signed(x_axis)\n\n            mat_rot = Matrix.Rotation(angle, 2, \"Z\")\n            v_translation = (p2 + p1) / 2\n\n        elif e2.is_line():\n            # curve -&gt; line\n            # or point -&gt; line\n            if e1.is_curve():\n                if not align:\n                    v_rotation = p2 - p1\n                else:\n                    v_rotation = (\n                        Vector((1.0, 0.0))\n                        if alignment == \"HORIZONTAL\"\n                        else Vector((0.0, 1.0))\n                    )\n                if v_rotation.length != 0:\n                    angle = v_rotation.angle_signed(x_axis)\n\n                mat_rot = Matrix.Rotation(angle, 2, \"Z\")\n                v_translation = (p2 + p1) / 2\n            else:\n                assert isinstance(e1, SlvsPoint2D)\n                orig = e2.p1.co\n                end = e2.p2.co\n                vec = end - orig\n                angle = (math.tau / 4) + range_2pi(math.atan2(vec[1], vec[0]))\n                mat_rot = Matrix.Rotation(angle, 2, \"Z\")\n                p1 = p1 - orig\n                v_translation = orig + (p1 + p1.project(vec)) / 2\n\n        mat_local = Matrix.Translation(v_translation.to_3d()) @ mat_rot.to_4x4()\n        return sketch.wp.matrix_basis @ mat_local\n\n    def _get_init_value(self, alignment):\n        e1, e2 = self.entity1, self.entity2\n\n        if e1.is_3d():\n            return (e1.location - e2.location).length\n\n        if e1.is_line():\n            return _get_aligned_distance(e1.p1, e1.p2, alignment)\n        if type(e1) in CURVE:\n            centerpoint = e1.ct.co\n            if isinstance(e2, SlvsLine2D):\n                endpoint, _ = intersect_point_line(centerpoint, e2.p1.co, e2.p2.co)\n            else:\n                assert isinstance(e2, SlvsPoint2D)\n                endpoint = e2.co\n            return (centerpoint - endpoint).length - e1.radius\n        if isinstance(e2, SlvsWorkplane):\n            # Returns the signed distance to the plane\n            return distance_point_to_plane(e1.co, e2.p1.co, e2.normal)\n        if type(e2) in LINE:\n            orig = e2.p1.co\n            end = e2.p2.co - orig\n            p1 = e1.co - orig\n\n            # NOTE: Comment from solvespace documentation:\n            # When constraining the distance between a point and a plane,\n            # or a point and a plane face, or a point and a line in a workplane,\n            # the distance is signed. The distance may be positive or negative,\n            # depending on whether the point is above or below the plane.\n            # The distance is always shown positive on the sketch;\n            # to flip to the other side, enter a negative value.\n            return math.copysign(\n                (p1 - (p1).project(end)).length,\n                get_side_of_line(e2.p1.co, e2.p2.co, e1.co),\n            )\n\n        return _get_aligned_distance(e1, e2, alignment)\n\n    def init_props(self, **kwargs):\n\n        # NOTE: Flip is currently ignored when passed in kwargs\n        alignment = kwargs.get(\"align\")\n        retval = {}\n\n        value = kwargs.get(\"value\", self._get_init_value(alignment))\n\n        if self.use_flipping() and value &lt; 0:\n            value = abs(value)\n            retval[\"flip\"] = not self.flip\n\n        retval[\"value\"] = value\n        retval[\"align\"] = alignment\n        return retval\n\n    def text_inside(self, ui_scale):\n        return (ui_scale * abs(self.draw_outset)) &lt; self.value / 2\n\n    def update_draw_offset(self, pos, ui_scale):\n        self.draw_offset = pos[1] / ui_scale\n        self.draw_outset = pos[0] / ui_scale\n\n    def draw_props(self, layout):\n        sub = super().draw_props(layout)\n\n        row = sub.row()\n        row.enabled = self.use_flipping()\n        row.prop(self, \"flip\")\n\n        sub.label(text=\"Alignment:\")\n        row = sub.row()\n        row.enabled = self.use_align()\n        row.prop(self, \"align\", text=\"\")\n\n        if preferences.is_experimental():\n            sub.prop(self, \"draw_offset\")\n\n        return sub\n\n    def value_placement(self, context):\n        \"\"\"location to display the constraint value\"\"\"\n        region = context.region\n        rv3d = context.space_data.region_3d\n        ui_scale = context.preferences.system.ui_scale\n\n        offset = ui_scale * self.draw_offset\n        outset = ui_scale * self.draw_outset\n        coords = self.matrix_basis() @ Vector((outset, offset, 0))\n        return location_3d_to_region_2d(region, rv3d, coords)\n</code></pre> <p>               Bases: <code>DimensionalConstraint</code>, <code>PropertyGroup</code></p> <p>Sets the diameter of an arc or a circle.</p> Source code in <code>model/diameter.py</code> <pre><code>class SlvsDiameter(DimensionalConstraint, PropertyGroup):\n    \"\"\"Sets the diameter of an arc or a circle.\"\"\"\n\n    def use_radius_getter(self):\n        return self.get(\"setting\", self.bl_rna.properties[\"setting\"].default)\n\n    def use_radius_setter(self, setting):\n        old_setting = self.get(\"setting\", self.bl_rna.properties[\"setting\"].default)\n        self[\"setting\"] = setting\n\n        distance = None\n        if old_setting and not setting:\n            distance = self.value * 2\n        elif not old_setting and setting:\n            distance = self.value / 2\n\n        if distance is not None:\n            # Avoid triggering the property's update callback\n            self[\"value\"] = distance\n\n    @property\n    def label(self):\n        return \"Radius\" if self.setting else \"Diameter\"\n\n    value: FloatProperty(\n        name=\"Size\",\n        subtype=\"DISTANCE\",\n        unit=\"LENGTH\",\n        precision=6,\n        get=DimensionalConstraint._get_value,\n        set=DimensionalConstraint._set_value,\n        update=update_system_cb,\n    )\n    setting: BoolProperty(\n        name=\"Use Radius\", get=use_radius_getter, set=use_radius_setter\n    )\n    leader_angle: FloatProperty(name=\"Leader Angle\", default=45, subtype=\"ANGLE\")\n    draw_offset: FloatProperty(name=\"Draw Offset\", default=0)\n    type = \"DIAMETER\"\n    signature = (CURVE,)\n    props = (\"value\",)\n\n    @property\n    def diameter(self):\n        value = self.value\n        if self.setting:\n            return value * 2\n        return value\n\n    @property\n    def radius(self):\n        value = self.value\n        if self.setting:\n            return value\n        return value / 2\n\n    def needs_wp(self):\n        return WpReq.OPTIONAL\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        return solvesys.diameter(group, self.entity1.py_data, self.diameter)\n\n    def _get_init_value(self, setting):\n        value = self.entity1.radius\n        if not setting:\n            return value * 2\n        return value\n\n    def init_props(self, **kwargs):\n        setting = kwargs.get(\"setting\", self.setting)\n        value = kwargs.get(\"value\", self._get_init_value(setting))\n        return {\"value\": value, \"setting\": setting}\n\n    def matrix_basis(self):\n        if self.sketch_i == -1:\n            return Matrix()\n        sketch = self.sketch\n        origin = self.entity1.ct.co\n        rotation = range_2pi(math.radians(self.leader_angle))\n        mat_local = Matrix.Translation(origin.to_3d())\n        return sketch.wp.matrix_basis @ mat_local\n\n    def text_inside(self):\n        return self.draw_offset &lt; self.radius\n\n    def update_draw_offset(self, pos, ui_scale):\n        self.draw_offset = pos.length\n        self.leader_angle = math.atan2(pos.y, pos.x)\n\n    def value_placement(self, context):\n        \"\"\"location to display the constraint value\"\"\"\n        region = context.region\n        rv3d = context.space_data.region_3d\n        offset = self.draw_offset\n        coords = pol2cart(offset, self.leader_angle)\n        coords2 = self.matrix_basis() @ Vector((coords[0], coords[1], 0.0))\n        return location_3d_to_region_2d(region, rv3d, coords2)\n</code></pre> <p>               Bases: <code>DimensionalConstraint</code>, <code>PropertyGroup</code></p> <p>Sets the angle between two lines, applies in 2D only.</p> <p>The constraint's setting can be used to to constrain the supplementary angle.</p> Source code in <code>model/angle.py</code> <pre><code>class SlvsAngle(DimensionalConstraint, PropertyGroup):\n    \"\"\"Sets the angle between two lines, applies in 2D only.\n\n    The constraint's setting can be used to to constrain the supplementary angle.\n    \"\"\"\n\n    def assign_init_props(self, context: Context = None, **kwargs):\n        # Updating self.setting will create recursion loop\n\n        super().assign_init_props(context)\n\n        line1, line2 = self.entity1, self.entity2\n        origin = get_line_intersection(\n            *line_abc_form(line1.p1.co, line1.p2.co),\n            *line_abc_form(line2.p1.co, line2.p2.co),\n        )\n        dist = max(\n            (line1.midpoint() - origin).length, (line2.midpoint() - origin).length, 0.5\n        )\n        self.draw_offset = dist if not self.setting else -dist\n\n    label = \"Angle\"\n    value: FloatProperty(\n        name=label,\n        subtype=\"ANGLE\",\n        unit=\"ROTATION\",\n        precision=6,\n        update=update_system_cb,\n        get=DimensionalConstraint._get_value,\n        set=DimensionalConstraint._set_value,\n    )\n    setting: BoolProperty(\n        name=\"Measure supplementary angle\",\n        update=DimensionalConstraint.assign_init_props,\n    )\n    draw_offset: FloatProperty(name=\"Draw Offset\", default=1)\n    draw_outset: FloatProperty(name=\"Draw Outset\", default=0)\n    type = \"ANGLE\"\n    signature = ((SlvsLine2D,), (SlvsLine2D,))\n    props = (\"value\",)\n\n    def needs_wp(self):\n        return WpReq.NOT_FREE\n\n    def to_displayed_value(self, value):\n        return HALF_TURN - value if self.setting else value\n\n    def from_displayed_value(self, value):\n        return HALF_TURN - value if self.setting else value\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        wp = self.get_workplane()\n\n        return solvesys.angle(\n            group,\n            self.entity1.py_data,\n            self.entity2.py_data,\n            math.degrees(self.value),\n            wp,\n            self.setting,\n        )\n\n    def matrix_basis(self):\n        if self.sketch_i == -1:\n            return Matrix()\n\n        sketch = self.sketch\n\n        line1 = self.entity1\n        line2 = self.entity2\n\n        origin = get_line_intersection(\n            *line_abc_form(line1.p1.co, line1.p2.co),\n            *line_abc_form(line2.p1.co, line2.p2.co),\n        )\n\n        rotation = range_2pi((self.orientation(line2) + self.orientation(line1)) / 2)\n\n        if self.setting:\n            rotation = rotation - QUARTER_TURN\n\n        mat_rot = Matrix.Rotation(rotation, 2, \"Z\")\n        mat_local = Matrix.Translation(origin.to_3d()) @ mat_rot.to_4x4()\n        return sketch.wp.matrix_basis @ mat_local\n\n    @staticmethod\n    def orientation(line):\n        pos = line.p2.co - line.p1.co\n        return math.atan2(pos[1], pos[0])\n\n    @staticmethod\n    def _get_angle(A, B):\n        # (A dot B)/(|A||B|) = cos(valA)\n        divisor = A.length * B.length\n        if not divisor:\n            return 0.0\n\n        x = A.dot(B) / divisor\n        x = max(-1, min(x, 1))\n        return math.degrees(math.acos(x))\n\n    def _get_init_value(self, setting):\n        vec1, vec2 = self.entity1.direction_vec(), self.entity2.direction_vec()\n        return self._get_angle(vec1, vec2)\n\n    def init_props(self, **kwargs):\n        \"\"\"\n        initializes value (angle, in radians),\n            setting (\"measure supplimentary angle\")\n            and distance to dimension text (draw_offset)\n        \"\"\"\n\n        setting = kwargs.get(\"setting\", self.setting)\n        angle = kwargs.get(\"value\", self._get_init_value(setting))\n\n        return {\n            \"value\": math.radians(angle),\n            \"setting\": setting,\n        }\n\n    def text_inside(self):\n        return abs(self.draw_outset) &lt; (self.value / 2)\n\n    def update_draw_offset(self, pos, ui_scale):\n        self.draw_offset = math.copysign(pos.length / ui_scale, pos.x)\n        self.draw_outset = math.atan(pos.y / pos.x)\n\n    def value_placement(self, context):\n        \"\"\"location to display the constraint value\"\"\"\n        region = context.region\n        rv3d = context.space_data.region_3d\n        ui_scale = context.preferences.system.ui_scale\n\n        offset = ui_scale * self.draw_offset\n        outset = self.draw_outset\n        co = pol2cart(offset, outset)\n        coords = self.matrix_basis() @ Vector((co[0], co[1], 0))\n        return location_3d_to_region_2d(region, rv3d, coords)\n</code></pre>"},{"location":"constraints/#CAD_Sketcher.model.types.SlvsDistance.is_align","title":"<code>is_align()</code>","text":"<p>Returns True if constraint is aligned</p> Source code in <code>model/distance.py</code> <pre><code>def is_align(self):\n    \"\"\"Returns True if constraint is aligned\"\"\"\n    return self.use_align() and self.align != \"NONE\"\n</code></pre>"},{"location":"constraints/#CAD_Sketcher.model.types.SlvsDistance.use_align","title":"<code>use_align()</code>","text":"<p>Returns True if constraint's entities allow distance to be aligned</p> Source code in <code>model/distance.py</code> <pre><code>def use_align(self):\n    \"\"\"Returns True if constraint's entities allow distance to be aligned\"\"\"\n    if type(self.entity2) in (*LINE, SlvsWorkplane):\n        return False\n    if self.entity1.is_curve():\n        return False\n    return True\n</code></pre>"},{"location":"constraints/#CAD_Sketcher.model.types.SlvsDistance.value_placement","title":"<code>value_placement(context)</code>","text":"<p>location to display the constraint value</p> Source code in <code>model/distance.py</code> <pre><code>def value_placement(self, context):\n    \"\"\"location to display the constraint value\"\"\"\n    region = context.region\n    rv3d = context.space_data.region_3d\n    ui_scale = context.preferences.system.ui_scale\n\n    offset = ui_scale * self.draw_offset\n    outset = ui_scale * self.draw_outset\n    coords = self.matrix_basis() @ Vector((outset, offset, 0))\n    return location_3d_to_region_2d(region, rv3d, coords)\n</code></pre>"},{"location":"constraints/#CAD_Sketcher.model.types.SlvsDiameter.value_placement","title":"<code>value_placement(context)</code>","text":"<p>location to display the constraint value</p> Source code in <code>model/diameter.py</code> <pre><code>def value_placement(self, context):\n    \"\"\"location to display the constraint value\"\"\"\n    region = context.region\n    rv3d = context.space_data.region_3d\n    offset = self.draw_offset\n    coords = pol2cart(offset, self.leader_angle)\n    coords2 = self.matrix_basis() @ Vector((coords[0], coords[1], 0.0))\n    return location_3d_to_region_2d(region, rv3d, coords2)\n</code></pre>"},{"location":"constraints/#CAD_Sketcher.model.types.SlvsAngle.init_props","title":"<code>init_props(**kwargs)</code>","text":"<p>initializes value (angle, in radians),     setting (\"measure supplimentary angle\")     and distance to dimension text (draw_offset)</p> Source code in <code>model/angle.py</code> <pre><code>def init_props(self, **kwargs):\n    \"\"\"\n    initializes value (angle, in radians),\n        setting (\"measure supplimentary angle\")\n        and distance to dimension text (draw_offset)\n    \"\"\"\n\n    setting = kwargs.get(\"setting\", self.setting)\n    angle = kwargs.get(\"value\", self._get_init_value(setting))\n\n    return {\n        \"value\": math.radians(angle),\n        \"setting\": setting,\n    }\n</code></pre>"},{"location":"constraints/#CAD_Sketcher.model.types.SlvsAngle.value_placement","title":"<code>value_placement(context)</code>","text":"<p>location to display the constraint value</p> Source code in <code>model/angle.py</code> <pre><code>def value_placement(self, context):\n    \"\"\"location to display the constraint value\"\"\"\n    region = context.region\n    rv3d = context.space_data.region_3d\n    ui_scale = context.preferences.system.ui_scale\n\n    offset = ui_scale * self.draw_offset\n    outset = self.draw_outset\n    co = pol2cart(offset, outset)\n    coords = self.matrix_basis() @ Vector((co[0], co[1], 0))\n    return location_3d_to_region_2d(region, rv3d, coords)\n</code></pre>"},{"location":"entities/","title":"Entities","text":"<p>Entities are the basic elements which are used to draw geometry in CAD Sketcher. They differ from regular blender mesh or curve elements which means native blender tools aren't able to interact with it as long as they aren't converted. See the chapter integration for further details on how to process extension specific geometry.</p> <p>Entities are defined by a set of parameters and pointers to other entities which are editable at any point in time. This allows non-destructive workflows and also ensures that geometry is resolution independent. A curve will always follow a given radius no matter how it's transformed. Entities can be created with the various Workspacetools.</p>"},{"location":"entities/#active","title":"Active","text":"<p>An entity is considered to be active when the sketch it belongs to is set as the active sketch or, for 3D entities, when no sketch is active.</p>"},{"location":"entities/#visibility","title":"Visibility","text":"<p>Entities can be hidden. Access the setting from the entity's context menu or from the entity browser.</p>"},{"location":"entities/#construction","title":"Construction","text":"<p>Entities have a construction parameter which can be set via the entity's context menu. If it's set to true the entity will be ignored when converting the geometry however it's still used to solve the geometric system. It's generally good practice to mark entities as construction if they're not part of the final geometry.</p>"},{"location":"entities/#fixed","title":"Fixed","text":"<p>Entities can be fixed via the entity's context menu. A fixed entity won't have any degrees of freedom and therefor cannot be adjusted by the solver. It's good practice to base geometry on a fixed origin point.</p> <p>Warning: While this currently applies to all entities it's intended to be used with points only.</p>"},{"location":"entities/#types","title":"Types","text":"<p>There are different types of entities, some of them apply in 2 dimensional space which requires a sketch as a parameter.</p> <p>Entity types follow the implementation of solvespace.</p> <p>Only 2D entities can be converted later, check the chapter integration for details.</p> <p>               Bases: <code>Point3D</code>, <code>PropertyGroup</code></p> <p>Representation of a point in 3D Space.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>FloatVectorProperty</code> <p>Point's location in the form (x, y, z)</p> required Source code in <code>model/point_3d.py</code> <pre><code>class SlvsPoint3D(Point3D, PropertyGroup):\n    \"\"\"Representation of a point in 3D Space.\n\n    Arguments:\n        location (FloatVectorProperty): Point's location in the form (x, y, z)\n    \"\"\"\n\n    location: FloatVectorProperty(\n        name=\"Location\",\n        description=\"The location of the point\",\n        subtype=\"XYZ\",\n        unit=\"LENGTH\",\n        update=SlvsGenericEntity.tag_update,\n    )\n    props = (\"location\",)\n\n    def draw_props(self, layout):\n        sub = super().draw_props(layout)\n        sub.prop(self, \"location\")\n        return sub\n</code></pre> <p>               Bases: <code>SlvsGenericEntity</code>, <code>PropertyGroup</code></p> <p>Representation of a line in 3D Space.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>SlvsPoint3D</code> <p>Line's startpoint</p> required <code>p2</code> <code>SlvsPoint3D</code> <p>Line's endpoint</p> required Source code in <code>model/line_3d.py</code> <pre><code>class SlvsLine3D(SlvsGenericEntity, PropertyGroup):\n    \"\"\"Representation of a line in 3D Space.\n\n    Arguments:\n        p1 (SlvsPoint3D): Line's startpoint\n        p2 (SlvsPoint3D): Line's endpoint\n    \"\"\"\n\n    @classmethod\n    def is_path(cls):\n        return True\n\n    @classmethod\n    def is_line(cls):\n        return True\n\n    @classmethod\n    def is_segment(cls):\n        return True\n\n    def dependencies(self) -&gt; List[SlvsGenericEntity]:\n        return [self.p1, self.p2]\n\n    def is_dashed(self):\n        return self.construction\n\n    def update(self):\n        if bpy.app.background:\n            return\n\n        p1, p2 = self.p1.location, self.p2.location\n        coords = (p1, p2)\n\n        kwargs = {\"pos\": coords}\n        self._batch = batch_for_shader(self._shader, \"LINES\", kwargs)\n\n        self.is_dirty = False\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        handle = solvesys.add_line_3d(group, self.p1.py_data, self.p2.py_data)\n        self.py_data = handle\n\n    def closest_picking_point(self, origin, view_vector):\n        \"\"\"Returns the point on this entity which is closest to the picking ray\"\"\"\n        p1 = self.p1.location\n        d1 = self.p2.location - p1  # normalize?\n        return nearest_point_line_line(p1, d1, origin, view_vector)\n\n    def placement(self):\n        return (self.p1.location + self.p2.location) / 2\n\n    def orientation(self):\n        return (self.p2.location - self.p1.location).normalized()\n\n    @property\n    def length(self):\n        return (self.p2.location - self.p1.location).length\n</code></pre> <p>               Bases: <code>Normal3D</code>, <code>PropertyGroup</code></p> <p>Representation of a normal in 3D Space which is used to store a direction.</p> <p>This entity isn't currently exposed to the user and gets created implicitly when needed.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>Quaternion</code> <p>A quaternion which describes the rotation</p> required Source code in <code>model/normal_3d.py</code> <pre><code>class SlvsNormal3D(Normal3D, PropertyGroup):\n    \"\"\"Representation of a normal in 3D Space which is used to\n    store a direction.\n\n    This entity isn't currently exposed to the user and gets created\n    implicitly when needed.\n\n    Arguments:\n        orientation (Quaternion): A quaternion which describes the rotation\n    \"\"\"\n\n    def get_orientation(self):\n        return getattr(self, \"orientation\").to_euler()\n\n    def set_orientation(self, value):\n        self[\"orientation\"] = Euler(value).to_quaternion()\n\n    orientation: FloatVectorProperty(\n        name=\"Orientation\",\n        description=\"Quaternion which describes the orientation of the normal\",\n        subtype=\"QUATERNION\",\n        size=4,\n        update=SlvsGenericEntity.tag_update,\n    )\n\n    ui_orientation: FloatVectorProperty(\n        name=\"Orientation\",\n        subtype=\"EULER\",\n        size=3,\n        get=get_orientation,\n        set=set_orientation,\n        options={\"SKIP_SAVE\"},\n        update=SlvsGenericEntity.tag_update,\n    )\n    props = (\"ui_orientation\",)\n\n    def draw_props(self, layout):\n        sub = super().draw_props(layout)\n        sub.prop(self, \"ui_orientation\")\n        return sub\n</code></pre> <p>               Bases: <code>SlvsGenericEntity</code>, <code>PropertyGroup</code></p> <p>Representation of a plane which is defined by an origin point and a normal. Workplanes are used to define the position of 2D entities which only store the coordinates on the plane.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>SlvsPoint3D</code> <p>Origin Point of the Plane</p> required <code>nm</code> <code>SlvsNormal3D</code> <p>Normal which defines the orientation</p> required Source code in <code>model/workplane.py</code> <pre><code>class SlvsWorkplane(SlvsGenericEntity, PropertyGroup):\n    \"\"\"Representation of a plane which is defined by an origin point\n    and a normal. Workplanes are used to define the position of 2D entities\n    which only store the coordinates on the plane.\n\n    Arguments:\n        p1 (SlvsPoint3D): Origin Point of the Plane\n        nm (SlvsNormal3D): Normal which defines the orientation\n    \"\"\"\n\n    size = 0.4\n\n    def dependencies(self) -&gt; List[SlvsGenericEntity]:\n        return [self.p1, self.nm]\n\n    @property\n    def size(self):\n        return preferences.get_prefs().workplane_size\n\n    def update(self):\n        if bpy.app.background:\n            return\n\n        p1, nm = self.p1, self.nm\n\n        coords = draw_rect_2d(0, 0, self.size, self.size)\n        coords = [(Vector(co))[:] for co in coords]\n\n        indices = ((0, 1), (1, 2), (2, 3), (3, 0))\n        self._batch = batch_for_shader(\n            self._shader, \"LINES\", {\"pos\": coords}, indices=indices\n        )\n        self.is_dirty = False\n\n    # NOTE: probably better to avoid overwriting draw func..\n    def draw(self, context):\n        if not self.is_visible(context):\n            return\n\n        with gpu.matrix.push_pop():\n            scale = context.region_data.view_distance\n            gpu.matrix.multiply_matrix(self.matrix_basis)\n            gpu.matrix.scale(Vector((scale, scale, scale)))\n\n            col = self.color(context)\n            # Let parent draw outline\n            super().draw(context)\n\n            # Additionally draw a face\n            col_surface = col[:-1] + (0.2,)\n\n            shader = Shaders.uniform_color_3d()\n            shader.bind()\n            gpu.state.blend_set(\"ALPHA\")\n\n            shader.uniform_float(\"color\", col_surface)\n\n            coords = draw_rect_2d(0, 0, self.size, self.size)\n            coords = [Vector(co)[:] for co in coords]\n            indices = ((0, 1, 2), (0, 2, 3))\n            batch = batch_for_shader(shader, \"TRIS\", {\"pos\": coords}, indices=indices)\n            batch.draw(shader)\n\n        self.restore_opengl_defaults()\n\n    def draw_id(self, context):\n        with gpu.matrix.push_pop():\n            scale = context.region_data.view_distance\n            gpu.matrix.multiply_matrix(self.matrix_basis)\n            gpu.matrix.scale(Vector((scale, scale, scale)))\n            super().draw_id(context)\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        handle = solvesys.add_workplane(group, self.p1.py_data, self.nm.py_data)\n        self.py_data = handle\n\n    @property\n    def matrix_basis(self):\n        mat_rot = self.nm.orientation.to_matrix().to_4x4()\n        return Matrix.Translation(self.p1.location) @ mat_rot\n\n    @property\n    def normal(self):\n        v = global_data.Z_AXIS.copy()\n        quat = self.nm.orientation\n        v.rotate(quat)\n        return v\n\n    def draw_props(self, layout):\n        # Display the normals props as they're not drawn in the viewport\n        sub = self.nm.draw_props(layout)\n        sub.operator(Operators.AlignWorkplaneCursor).index = self.slvs_index\n        return sub\n</code></pre> <p>               Bases: <code>SlvsGenericEntity</code>, <code>PropertyGroup</code></p> <p>A sketch groups 2 dimensional entities together and is used to later convert geometry to native blender types.</p> <p>Entities that belong to a sketch can only be edited as long as the sketch is active.</p> <p>Parameters:</p> Name Type Description Default <code>wp</code> <code>SlvsWorkplane</code> <p>The base workplane of the sketch</p> required Source code in <code>model/sketch.py</code> <pre><code>class SlvsSketch(SlvsGenericEntity, PropertyGroup):\n    \"\"\"A sketch groups 2 dimensional entities together and is used to later\n    convert geometry to native blender types.\n\n    Entities that belong to a sketch can only be edited as long as the sketch is active.\n\n    Arguments:\n        wp (SlvsWorkplane): The base workplane of the sketch\n    \"\"\"\n\n    def hide_sketch(self, context):\n        if self.convert_type != \"NONE\":\n            self.visible = False\n\n    convert_type: EnumProperty(\n        name=\"Convert Type\",\n        items=convert_items,\n        description=\"Define how the sketch should be converted in order to be usable in native blender\",\n        update=hide_sketch,\n    )\n    fill_shape: BoolProperty(\n        name=\"Fill Shape\",\n        description=\"Fill the resulting shape if it's closed\",\n        default=True,\n    )\n    solver_state: EnumProperty(\n        name=\"Solver Status\", items=global_data.solver_state_items\n    )\n    dof: IntProperty(name=\"Degrees of Freedom\", max=6)\n    target_curve: PointerProperty(type=bpy.types.Curve)\n    target_curve_object: PointerProperty(type=bpy.types.Object)\n    target_mesh: PointerProperty(type=bpy.types.Mesh)\n    target_object: PointerProperty(type=bpy.types.Object)\n    curve_resolution: IntProperty(\n        name=\"Mesh Curve Resolution\", default=12, min=1, soft_max=25\n    )\n\n    def dependencies(self) -&gt; List[SlvsGenericEntity]:\n        return [\n            self.wp,\n        ]\n\n    def sketch_entities(self, context):\n        for e in context.scene.sketcher.entities.all:\n            if not hasattr(e, \"sketch\"):\n                continue\n            if e.sketch != self:\n                continue\n            yield e\n\n    def update(self):\n        self.is_dirty = False\n\n    def draw(self, context):\n        pass\n\n    def draw_id(self, context):\n        pass\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        pass\n\n    def remove_objects(self):\n        for ob in (self.target_object, self.target_curve_object):\n            if not ob:\n                continue\n            bpy.data.objects.remove(ob)\n\n    def is_visible(self, context):\n        if context.scene.sketcher.active_sketch_i == self.slvs_index:\n            return True\n        return self.visible\n\n    def get_solver_state(self):\n        return bpyEnum(global_data.solver_state_items, identifier=self.solver_state)\n\n    def solve(self, context):\n        return solve_system(context, sketch=self)\n\n    @classmethod\n    def is_sketch(cls):\n        return True\n</code></pre> <p>               Bases: <code>Point2D</code>, <code>PropertyGroup</code></p> <p>Representation of a point in 2D space.</p> <p>Parameters:</p> Name Type Description Default <code>co</code> <code>FloatVectorProperty</code> <p>The coordinates of the point on the worpkplane in the form (U, V)</p> required <code>sketch</code> <code>SlvsSketch</code> <p>The sketch this entity belongs to</p> required Source code in <code>model/point_2d.py</code> <pre><code>class SlvsPoint2D(Point2D, PropertyGroup):\n    \"\"\"Representation of a point in 2D space.\n\n    Arguments:\n        co (FloatVectorProperty): The coordinates of the point on the worpkplane in the form (U, V)\n        sketch (SlvsSketch): The sketch this entity belongs to\n    \"\"\"\n\n    co: FloatVectorProperty(\n        name=\"Coordinates\",\n        description=\"The coordinates of the point on its sketch\",\n        subtype=\"XYZ\",\n        size=2,\n        unit=\"LENGTH\",\n        update=SlvsGenericEntity.tag_update,\n    )\n\n    def dependencies(self) -&gt; List[SlvsGenericEntity]:\n        return [\n            self.sketch,\n        ]\n\n    # def tweak(self, solvesys, pos, group):\n    #     wrkpln = self.sketch.wp\n    #     u, v, _ = wrkpln.matrix_basis.inverted() @ pos\n\n    #     self.create_slvs_data(solvesys, group=group)\n\n    #     p = solvesys.add_point_2d(group, u, v, wrkpln.py_data)\n    #     make_coincident(solvesys, p, self, wrkpln.py_data, group, entity_type=SlvsPoint2D)\n    #     solvesys.dragged(group, p, wrkpln.py_data)\n    #     return\n\n    def draw_props(self, layout):\n        sub = super().draw_props(layout)\n        sub.prop(self, \"co\")\n        return sub\n</code></pre> <p>               Bases: <code>Entity2D</code>, <code>PropertyGroup</code></p> <p>Representation of a line in 2D space. Connects p1 and p2 and lies on the sketche's workplane.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>SlvsPoint2D</code> <p>Line's startpoint</p> required <code>p2</code> <code>SlvsPoint2D</code> <p>Line's endpoint</p> required <code>sketch</code> <code>SlvsSketch</code> <p>The sketch this entity belongs to</p> required Source code in <code>model/line_2d.py</code> <pre><code>class SlvsLine2D(Entity2D, PropertyGroup):\n    \"\"\"Representation of a line in 2D space. Connects p1 and p2 and lies on the\n    sketche's workplane.\n\n    Arguments:\n        p1 (SlvsPoint2D): Line's startpoint\n        p2 (SlvsPoint2D): Line's endpoint\n        sketch (SlvsSketch): The sketch this entity belongs to\n    \"\"\"\n\n    @classmethod\n    def is_path(cls):\n        return True\n\n    @classmethod\n    def is_line(cls):\n        return True\n\n    @classmethod\n    def is_segment(cls):\n        return True\n\n    def dependencies(self) -&gt; List[SlvsGenericEntity]:\n        return [self.p1, self.p2, self.sketch]\n\n    def is_dashed(self):\n        return self.construction\n\n    def update(self):\n        if bpy.app.background:\n            return\n\n        p1, p2 = self.p1.location, self.p2.location\n        coords = (p1, p2)\n\n        kwargs = {\"pos\": coords}\n        self._batch = batch_for_shader(self._shader, \"LINES\", kwargs)\n        self.is_dirty = False\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        handle = solvesys.add_line_2d(group, self.p1.py_data, self.p2.py_data, self.wp.py_data)\n        self.py_data = handle\n\n    def closest_picking_point(self, origin, view_vector):\n        \"\"\"Returns the point on this entity which is closest to the picking ray\"\"\"\n        # NOTE: for 2d entities it could be enough precise to simply take the intersection point with the workplane\n        p1 = self.p1.location\n        d1 = self.p2.location - p1  # normalize?\n        return nearest_point_line_line(p1, d1, origin, view_vector)\n\n    def project_point(self, coords):\n        \"\"\"Projects a point onto the line\"\"\"\n        dir_vec = self.direction_vec()\n        p1 = self.p1.co\n\n        local_co = coords - p1\n        return local_co.project(dir_vec) + p1\n\n    def placement(self):\n        return (self.p1.location + self.p2.location) / 2\n\n    def connection_points(self, direction: bool = False):\n        points = [self.p1, self.p2]\n        if direction:\n            return list(reversed(points))\n        return points\n\n    def direction(self, point, is_endpoint=False):\n        \"\"\"Returns the direction of the line, true if inverted\"\"\"\n        if is_endpoint:\n            return point == self.p1\n        else:\n            return point == self.p2\n\n    def connection_angle(self, other, **kwargs):\n        \"\"\"Returns the angle at the connection point between the two entities\n        or None if they're not connected or not in 2d space.\n\n        `kwargs` key values are propagated to other `get_connection_point` functions\n        \"\"\"\n\n        if self.is_3d() or other.is_3d():\n            return None\n\n        if not all([e.is_line() for e in (self, other)]):\n            return other.connection_angle(self, **kwargs)\n\n        point = get_connection_point(\n            self,\n            other,\n        )\n        if not point:\n            return None\n\n        dir1 = (\n            self.direction_vec()\n            if self.direction(point)\n            else (self.direction_vec() * (-1))\n        )\n        dir2 = (\n            other.direction_vec()\n            if other.direction(point)\n            else (other.direction_vec() * (-1))\n        )\n        return dir1.angle_signed(dir2)\n\n    def to_bezier(\n        self, spline, startpoint, endpoint, invert_direction, set_startpoint=False\n    ):\n        locations = [self.p1.co.to_3d(), self.p2.co.to_3d()]\n        if invert_direction:\n            locations.reverse()\n\n        if set_startpoint:\n            startpoint.co = locations[0]\n        endpoint.co = locations[1]\n\n        startpoint.handle_right = locations[0]\n        endpoint.handle_left = locations[1]\n\n        return endpoint\n\n    def midpoint(self):\n        return (self.p1.co + self.p2.co) / 2\n\n    def orientation(self):\n        \"\"\"Return the orientation of the line in 3d space\"\"\"\n        return (self.p2.location - self.p1.location).normalized()\n\n    def direction_vec(self):\n        return (self.p2.co - self.p1.co).normalized()\n\n    def normal(self, position=None):\n        \"\"\"Returns vector perpendicular to line, position is ignored\"\"\"\n        mat_rot = Matrix.Rotation(-math.pi / 2, 2, \"Z\")\n        nm = self.direction_vec()\n        nm.rotate(mat_rot)\n        return nm\n\n    @property\n    def length(self):\n        return (self.p2.co - self.p1.co).length\n\n    def overlaps_endpoint(self, co):\n        precision = 5\n        co_rounded = round_v(co, ndigits=precision)\n        if any(\n            [\n                co_rounded == round_v(v, ndigits=precision)\n                for v in (self.p1.co, self.p2.co)\n            ]\n        ):\n            return True\n        return False\n\n    def intersect(\n        self, other: SlvsGenericEntity, extended: bool = False\n    ) -&gt; Tuple[Vector]:\n        # NOTE: There can be multiple intersections when intersecting with one or more curves\n        def parse_retval(value):\n            if not value:\n                return ()\n            if self.overlaps_endpoint(value) or other.overlaps_endpoint(value):\n                return ()\n            return (value,)\n\n        if other.is_line():\n            if extended:\n                wp = self.sketch.wp\n                pos = intersect_line_line(\n                    self.p1.location,\n                    self.p2.location,\n                    other.p1.location,\n                    other.p2.location,\n                )\n                return parse_retval((wp.matrix_basis @ pos[0])[:-1])\n            return parse_retval(\n                intersect_line_line_2d(self.p1.co, self.p2.co, other.p1.co, other.p2.co)\n            )\n        return other.intersect(self)\n\n    def replace(self, context, p1, p2, use_self=False):\n        # Replace entity by a similar entity with the connection points p1, and p2\n        # This is used for trimming, points are expected to lie somewhere on the existing entity\n        if use_self:\n            self.p1 = p1\n            self.p2 = p2\n            return self\n\n        sse = context.scene.sketcher.entities\n        sketch = context.scene.sketcher.active_sketch\n        line = sse.add_line_2d(\n            p1,\n            p2,\n            sketch,\n        )\n        line.construction = self.construction\n        return line\n\n    def distance_along_segment(self, p1, p2):\n        start, end = self.p1.co, self.p2.co\n        len_1 = (p1 - end).length\n        len_2 = (p2 - start).length\n\n        threshold = 0.0000001\n        retval = (len_1 + len_2) % (self.length + threshold)\n\n        return retval\n\n    def replace_point(self, old, new):\n        for ptr in (\"p1\", \"p2\"):\n            if old != getattr(self, ptr):\n                continue\n            setattr(self, ptr, new)\n            break\n\n    def get_offset_props(self, offset: float, direction: bool = False):\n        normal = self.normal()\n\n        if direction:\n            normal *= -1\n\n        offset_vec = normal * offset\n        return (self.p1.co + offset_vec, self.p2.co + offset_vec)\n\n    def new(self, context: Context, **kwargs) -&gt; SlvsGenericEntity:\n        kwargs.setdefault(\"p1\", self.p1)\n        kwargs.setdefault(\"p2\", self.p2)\n        kwargs.setdefault(\"sketch\", self.sketch)\n        kwargs.setdefault(\"construction\", self.construction)\n        return context.scene.sketcher.entities.add_line_2d(**kwargs)\n</code></pre> <p>               Bases: <code>Entity2D</code>, <code>PropertyGroup</code></p> <p>Representation of an arc in 2D space around the centerpoint ct. Connects p2 to p3 or (vice-versa if the option invert_direction is true) with a circle segment that is resolution independent. The arc lies on the sketche's workplane.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>SlvsPoint2D</code> <p>Arc's centerpoint</p> required <code>p2</code> <code>SlvsPoint2D</code> <p>Arc's startpoint</p> required <code>p2</code> <code>SlvsPoint2D</code> <p>Arc's endpoint</p> required <code>nm</code> <code>SlvsNormal3D</code> <p>Orientation</p> required <code>sketch</code> <code>SlvsSketch</code> <p>The sketch this entity belongs to</p> required Source code in <code>model/arc.py</code> <pre><code>class SlvsArc(Entity2D, PropertyGroup):\n    \"\"\"Representation of an arc in 2D space around the centerpoint ct. Connects\n    p2 to p3 or (vice-versa if the option invert_direction is true) with a\n    circle segment that is resolution independent. The arc lies on the sketche's workplane.\n\n    Arguments:\n        p1 (SlvsPoint2D): Arc's centerpoint\n        p2 (SlvsPoint2D): Arc's startpoint\n        p2 (SlvsPoint2D): Arc's endpoint\n        nm (SlvsNormal3D): Orientation\n        sketch (SlvsSketch): The sketch this entity belongs to\n    \"\"\"\n\n    invert_direction: BoolProperty(\n        name=\"Invert direction\",\n        description=\"Connect the points in the inverted order\",\n        update=tag_update,\n    )\n\n    @classmethod\n    def is_path(cls):\n        return True\n\n    @classmethod\n    def is_curve(cls):\n        return True\n\n    @classmethod\n    def is_segment(cls):\n        return True\n\n    @property\n    def start(self):\n        return self.p2 if self.invert_direction else self.p1\n\n    @property\n    def end(self):\n        return self.p1 if self.invert_direction else self.p2\n\n    def dependencies(self) -&gt; List[SlvsGenericEntity]:\n        return [self.nm, self.ct, self.start, self.end, self.sketch]\n\n    def is_dashed(self):\n        return self.construction\n\n    def update(self):\n        if bpy.app.background:\n            return\n\n        ct = self.ct.co\n        p1 = self.start.co - ct\n        p2 = self.end.co - ct\n\n        radius = p1.length\n\n        coords = []\n        if radius and p2.length:\n            offset = p1.angle_signed(Vector((1, 0)))\n            angle = range_2pi(p2.angle_signed(p1))\n\n            # TODO: resolution should depend on segment length?!\n            segments = round(CURVE_RESOLUTION * (angle / FULL_TURN))\n\n            coords = coords_arc_2d(0, 0, radius, segments, angle=angle, offset=offset)\n\n            mat_local = Matrix.Translation(self.ct.co.to_3d())\n            mat = self.wp.matrix_basis @ mat_local\n            coords = [(mat @ Vector((*co, 0)))[:] for co in coords]\n\n        kwargs = {\"pos\": coords}\n        self._batch = batch_for_shader(self._shader, \"LINE_STRIP\", kwargs)\n        self.is_dirty = False\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        handle = solvesys.add_arc(\n            group,\n            self.wp.nm.py_data,\n            self.ct.py_data,\n            self.start.py_data,\n            self.end.py_data,\n            self.wp.py_data,\n        )\n        self.py_data = handle\n\n    @property\n    def radius(self):\n        return (self.ct.co - self.start.co).length\n\n    @property\n    def angle(self):\n        \"\"\"Returns an angle in radians from zero to 2*PI\"\"\"\n        center = self.ct.co\n        start, end = self.start.co - center, self.end.co - center\n        return _get_angle(start, end)\n\n    @property\n    def start_angle(self):\n        center, start = self.ct.co, self.start.co\n        return math.atan2((start - center)[1], (start - center)[0])\n\n    def normal(self, position: Vector = None):\n        \"\"\"Return the normal vector at a given position\"\"\"\n\n        normal = position - self.ct.co\n        return normal.normalized()\n\n    def placement(self):\n        coords = self.ct.co + pol2cart(self.radius, self.start_angle + self.angle / 2)\n\n        return self.wp.matrix_basis @ coords.to_3d()\n\n    def connection_points(self, direction: bool = False):\n        points = [self.start, self.end]\n        if direction:\n            return list(reversed(points))\n        return points\n\n    def direction(self, point, is_endpoint=False):\n        \"\"\"Returns the direction of the arc, true if inverted\"\"\"\n        if is_endpoint:\n            return point == self.start\n        return point == self.end\n\n    @staticmethod\n    def _direction(start, end, center):\n        pass\n\n    def bezier_segment_count(self):\n        max_angle = QUARTER_TURN\n        return math.ceil(self.angle / max_angle)\n\n    def bezier_point_count(self):\n        return self.bezier_segment_count() + 1\n\n    def point_on_curve(self, angle, relative=True):\n        start_angle = self.start_angle if relative else 0\n        return pol2cart(self.radius, start_angle + angle) + self.ct.co\n\n    def project_point(self, coords):\n        \"\"\"Projects a point onto the arc\"\"\"\n        local_co = coords - self.ct.co\n        angle = range_2pi(math.atan2(local_co[1], local_co[0]))\n        return self.point_on_curve(angle, relative=False)\n\n    def connection_angle(self, other, connection_point=None, **kwargs):\n        \"\"\"Returns the angle at the connection point between the two entities\n        or None if they're either not connected or not in 2d space\n\n        You may use `connection_point` in order to remove ambiguity in case\n        multiple intersections point exist with other entity.\n\n        `kwargs` key values are propagated to other `get_connection_point` functions\n        \"\"\"\n\n        point = connection_point or get_connection_point(self, other)\n\n        if not point:\n            return None\n        if self.is_3d() or other.is_3d():\n            return None\n\n        def _get_tangent(arc, point):\n            local_co = point.co - arc.ct.co\n            angle = range_2pi(math.atan2(local_co.y, local_co.x))\n            mat_rot = Matrix.Rotation(angle, 2, \"Z\")\n            tangent = Vector((0, 1))\n            tangent.rotate(mat_rot)\n            invert = arc.direction(point)\n            if invert:\n                tangent *= -1\n            return tangent\n\n        # Get directions\n        directions = []\n        for entity in (self, other):\n            if entity.is_curve():\n                directions.append(_get_tangent(entity, point))\n            else:\n                directions.append(\n                    entity.direction_vec()\n                    if entity.direction(point)\n                    else entity.direction_vec() * (-1)\n                )\n\n        dir1, dir2 = directions\n        return dir1.angle_signed(dir2)\n\n    def to_bezier(\n        self,\n        spline,\n        startpoint,\n        endpoint,\n        invert_direction,\n        set_startpoint=False,\n        midpoints=[],\n    ):\n        # Get midpoint positions\n        segment_count = len(midpoints) + 1\n        curve_angle = self.angle\n        radius, center, start = self.radius, self.ct.co, self.start.co\n\n        midpoint_positions = get_bezier_curve_midpoint_positions(\n            self, segment_count, midpoints, curve_angle\n        )\n\n        angle = curve_angle / segment_count\n\n        locations = [self.start.co, *midpoint_positions, self.end.co]\n        bezier_points = [startpoint, *midpoints, endpoint]\n\n        if invert_direction:\n            locations.reverse()\n\n        if set_startpoint:\n            startpoint.co = locations[0].to_3d()\n\n        n = FULL_TURN / angle if angle != 0.0 else 0\n        q = (4 / 3) * math.tan(HALF_TURN / (2 * n))\n        base_offset = Vector((radius, q * radius))\n\n        create_bezier_curve(\n            segment_count,\n            bezier_points,\n            locations,\n            center,\n            base_offset,\n            invert=invert_direction,\n        )\n\n        return endpoint\n\n    def draw_props(self, layout):\n        sub = super().draw_props(layout)\n        sub.prop(self, \"invert_direction\")\n        return sub\n\n    def is_inside(self, coords):\n        # Checks if a position is inside the arcs angle range\n        ct = self.ct.co\n        p = coords - ct\n        p1 = self.start.co - ct\n        p2 = self.end.co - ct\n\n        x_axis = Vector((1, 0))\n\n        # angle_signed interprets clockwise as positive, so invert..\n        a1 = range_2pi(p.angle_signed(p1))\n        a2 = range_2pi(p2.angle_signed(p))\n\n        angle = self.angle\n\n        if not p.length or not p1.length or not p2.length:\n            return False\n\n        if a1 &lt; angle &gt; a2:\n            return True\n        return False\n\n    def overlaps_endpoint(self, co):\n        precision = 5\n        co_rounded = round_v(co, ndigits=precision)\n        if any(\n            [\n                co_rounded == round_v(v, ndigits=precision)\n                for v in (self.p1.co, self.p2.co)\n            ]\n        ):\n            return True\n        return False\n\n    def intersect(self, other):\n        def parse_retval(retval):\n            # Intersect might return None, (value, value) or (value, None)\n            values = []\n            if hasattr(retval, \"__len__\"):\n                for val in retval:\n                    if val is None:\n                        continue\n                    if not self.is_inside(val):\n                        continue\n                    if isinstance(other, SlvsArc) and not other.is_inside(val):\n                        continue\n                    if self.overlaps_endpoint(val) or other.overlaps_endpoint(val):\n                        continue\n\n                    values.append(val)\n            elif retval is not None:\n                if self.overlaps_endpoint(retval) or other.overlaps_endpoint(retval):\n                    return ()\n                values.append(retval)\n\n            return tuple(values)\n\n        if other.is_line():\n            return parse_retval(\n                intersect_line_sphere_2d(\n                    other.p1.co, other.p2.co, self.ct.co, self.radius\n                )\n            )\n        elif other.is_curve():\n            return parse_retval(\n                intersect_sphere_sphere_2d(\n                    self.ct.co, self.radius, other.ct.co, other.radius\n                )\n            )\n\n    def distance_along_segment(self, p1, p2):\n        ct = self.ct.co\n        start, end = self.start.co - ct, self.end.co - ct\n        points = (p1, p2) if self.invert_direction else (p2, p1)\n\n        len_1 = range_2pi(end.angle_signed(points[1] - ct))\n        len_2 = range_2pi((points[0] - ct).angle_signed(start))\n\n        threshold = 0.000001\n        retval = (len_1 + len_2) % (self.angle + threshold)\n\n        return retval\n\n    def replace(self, context, p1, p2, use_self=False):\n        if use_self:\n            self.p1 = p1\n            self.p2 = p2\n            return self\n\n        sketch = context.scene.sketcher.active_sketch\n        arc = context.scene.sketcher.entities.add_arc(\n            sketch.wp.nm, self.ct, p1, p2, sketch\n        )\n        arc.construction = self.construction\n        arc.invert_direction = self.invert_direction\n        return arc\n\n    def replace_point(self, old, new):\n        for ptr in (\"ct\", \"p1\", \"p2\"):\n            if old != getattr(self, ptr):\n                continue\n            setattr(self, ptr, new)\n            break\n\n    def new(self, context: Context, **kwargs) -&gt; SlvsGenericEntity:\n        kwargs.setdefault(\"p1\", self.p1)\n        kwargs.setdefault(\"p2\", self.p2)\n        kwargs.setdefault(\"sketch\", self.sketch)\n        kwargs.setdefault(\"nm\", self.nm)\n        kwargs.setdefault(\"ct\", self.ct)\n        kwargs.setdefault(\"invert\", self.invert_direction)\n        kwargs.setdefault(\"construction\", self.construction)\n        return context.scene.sketcher.entities.add_arc(**kwargs)\n</code></pre> <p>               Bases: <code>Entity2D</code>, <code>PropertyGroup</code></p> <p>Representation of a circle in 2D space. The circle is centered at ct with its size defined by the radius and is resoulution independent.</p> <p>Parameters:</p> Name Type Description Default <code>ct</code> <code>SlvsPoint2D</code> <p>Circle's centerpoint</p> required <code>radius</code> <code>FloatProperty</code> <p>The radius of the circle</p> required <code>nm</code> <code>SlvsNormal2D</code> required <code>sketch</code> <code>SlvsSketch</code> <p>The sketch this entity belongs to</p> required Source code in <code>model/circle.py</code> <pre><code>class SlvsCircle(Entity2D, PropertyGroup):\n    \"\"\"Representation of a circle in 2D space. The circle is centered at ct with\n    its size defined by the radius and is resoulution independent.\n\n    Arguments:\n        ct (SlvsPoint2D): Circle's centerpoint\n        radius (FloatProperty): The radius of the circle\n        nm (SlvsNormal2D):\n        sketch (SlvsSketch): The sketch this entity belongs to\n    \"\"\"\n\n    radius: FloatProperty(\n        name=\"Radius\",\n        description=\"The radius of the circle\",\n        subtype=\"DISTANCE\",\n        min=0.0,\n        unit=\"LENGTH\",\n        update=tag_update,\n    )\n\n    @classmethod\n    def is_path(cls):\n        return True\n\n    @classmethod\n    def is_curve(cls):\n        return True\n\n    @classmethod\n    def is_segment(cls):\n        return True\n\n    def dependencies(self) -&gt; List[SlvsGenericEntity]:\n        return [self.nm, self.ct, self.sketch]\n\n    def is_dashed(self):\n        return self.construction\n\n    def update(self):\n        if bpy.app.background:\n            return\n\n        coords = coords_arc_2d(0, 0, self.radius, CURVE_RESOLUTION)\n\n        u, v = self.ct.co\n\n        mat_local = Matrix.Translation(Vector((u, v, 0)))\n        mat = self.wp.matrix_basis @ mat_local\n        coords = [(mat @ Vector((*co, 0)))[:] for co in coords]\n\n        kwargs = {\"pos\": coords}\n        self._batch = batch_for_shader(self._shader, \"LINE_STRIP\", kwargs)\n        self.is_dirty = False\n\n    def create_slvs_data(self, solvesys, group=Solver.group_fixed):\n        self.param_distance = solvesys.add_distance(group, self.radius, self.wp.py_data)\n\n        nm = None\n        if self.nm != -1:\n            nm = self.nm\n        else:\n            nm = self.wp.nm\n\n        handle = solvesys.add_circle(\n            group,\n            self.wp.nm.py_data,\n            self.ct.py_data,\n            self.param_distance,\n            self.wp.py_data,\n        )\n        self.py_data = handle\n\n    def update_from_slvs(self, solvesys):\n        self.radius = solvesys.get_param_value(self.param_distance['param'][0])\n\n    def point_on_curve(self, angle):\n        return pol2cart(self.radius, angle) + self.ct.co\n\n    def placement(self):\n        return self.wp.matrix_basis @ self.point_on_curve(45).to_3d()\n\n    @classmethod\n    def is_closed(cls):\n        return True\n\n    def connection_points(self):\n        # NOTE: it should probably be possible to lookup coincident points on circle\n        return []\n\n    def direction(self, point, is_endpoint=False):\n        return False\n\n    def bezier_segment_count(self):\n        return 4\n\n    def bezier_point_count(self):\n        return self.bezier_segment_count()\n\n    def to_bezier(\n        self,\n        spline,\n        startpoint,\n        endpoint,\n        invert_direction,\n        set_startpoint=False,\n        midpoints=[],\n    ):\n        # Get midpoint positions\n        segment_count = len(midpoints) + 1\n        radius, center = self.radius, self.ct.co\n\n        bezier_points = [startpoint, *midpoints]\n\n        locations = get_bezier_curve_midpoint_positions(\n            self, segment_count, bezier_points, FULL_TURN, cyclic=True\n        )\n        angle = FULL_TURN / segment_count\n\n        n = FULL_TURN / angle\n        q = (4 / 3) * math.tan(HALF_TURN / (2 * n))\n        base_offset = Vector((radius, q * radius))\n\n        create_bezier_curve(\n            segment_count,\n            bezier_points,\n            locations,\n            center,\n            base_offset,\n            invert=invert_direction,\n            cyclic=True,\n        )\n        return endpoint\n\n    def overlaps_endpoint(self, co):\n        return False\n\n    def intersect(self, other):\n        def parse_retval(retval):\n            # Intersect might return None, (value, value) or (value, None)\n            values = []\n            if hasattr(retval, \"__len__\"):\n                for val in retval:\n                    if val is None:\n                        continue\n                    if other.overlaps_endpoint(val):\n                        continue\n                    values.append(val)\n            elif retval is not None:\n                if other.overlaps_endpoint(retval):\n                    return ()\n                values.append(retval)\n\n            return tuple(values)\n\n        if other.is_line():\n            return parse_retval(\n                intersect_line_sphere_2d(\n                    other.p1.co, other.p2.co, self.ct.co, self.radius\n                )\n            )\n        elif isinstance(other, SlvsCircle):\n            return parse_retval(\n                intersect_sphere_sphere_2d(\n                    self.ct.co, self.radius, other.ct.co, other.radius\n                )\n            )\n        else:\n            return other.intersect(self)\n\n    def replace(self, context, p1, p2, use_self=False):\n        if use_self:\n            self.p1 = p1\n            self.p2 = p2\n            return self\n\n        sketch = context.scene.sketcher.active_sketch\n        arc = context.scene.sketcher.entities.add_arc(\n            sketch.wp.nm, self.ct, p1, p2, sketch\n        )\n        arc.construction = self.construction\n        return arc\n\n    def distance_along_segment(self, p1, p2):\n        ct = self.ct.co\n        start, end = p1 - ct, p2 - ct\n        angle = range_2pi(math.atan2(*end.yx) - math.atan2(*start.yx))\n        retval = self.radius * angle\n        return retval\n\n\n    def new(self, context, **kwargs) -&gt; SlvsGenericEntity:\n        kwargs.setdefault(\"ct\", self.ct)\n        kwargs.setdefault(\"nm\", self.nm)\n        kwargs.setdefault(\"radius\", self.radius)\n        kwargs.setdefault(\"sketch\", self.sketch)\n        kwargs.setdefault(\"construction\", self.construction)\n        return context.scene.sketcher.entities.add_circle(**kwargs)\n</code></pre>"},{"location":"entities/#CAD_Sketcher.model.types.SlvsLine3D.closest_picking_point","title":"<code>closest_picking_point(origin, view_vector)</code>","text":"<p>Returns the point on this entity which is closest to the picking ray</p> Source code in <code>model/line_3d.py</code> <pre><code>def closest_picking_point(self, origin, view_vector):\n    \"\"\"Returns the point on this entity which is closest to the picking ray\"\"\"\n    p1 = self.p1.location\n    d1 = self.p2.location - p1  # normalize?\n    return nearest_point_line_line(p1, d1, origin, view_vector)\n</code></pre>"},{"location":"entities/#CAD_Sketcher.model.types.SlvsLine2D.closest_picking_point","title":"<code>closest_picking_point(origin, view_vector)</code>","text":"<p>Returns the point on this entity which is closest to the picking ray</p> Source code in <code>model/line_2d.py</code> <pre><code>def closest_picking_point(self, origin, view_vector):\n    \"\"\"Returns the point on this entity which is closest to the picking ray\"\"\"\n    # NOTE: for 2d entities it could be enough precise to simply take the intersection point with the workplane\n    p1 = self.p1.location\n    d1 = self.p2.location - p1  # normalize?\n    return nearest_point_line_line(p1, d1, origin, view_vector)\n</code></pre>"},{"location":"entities/#CAD_Sketcher.model.types.SlvsLine2D.connection_angle","title":"<code>connection_angle(other, **kwargs)</code>","text":"<p>Returns the angle at the connection point between the two entities or None if they're not connected or not in 2d space.</p> <p><code>kwargs</code> key values are propagated to other <code>get_connection_point</code> functions</p> Source code in <code>model/line_2d.py</code> <pre><code>def connection_angle(self, other, **kwargs):\n    \"\"\"Returns the angle at the connection point between the two entities\n    or None if they're not connected or not in 2d space.\n\n    `kwargs` key values are propagated to other `get_connection_point` functions\n    \"\"\"\n\n    if self.is_3d() or other.is_3d():\n        return None\n\n    if not all([e.is_line() for e in (self, other)]):\n        return other.connection_angle(self, **kwargs)\n\n    point = get_connection_point(\n        self,\n        other,\n    )\n    if not point:\n        return None\n\n    dir1 = (\n        self.direction_vec()\n        if self.direction(point)\n        else (self.direction_vec() * (-1))\n    )\n    dir2 = (\n        other.direction_vec()\n        if other.direction(point)\n        else (other.direction_vec() * (-1))\n    )\n    return dir1.angle_signed(dir2)\n</code></pre>"},{"location":"entities/#CAD_Sketcher.model.types.SlvsLine2D.direction","title":"<code>direction(point, is_endpoint=False)</code>","text":"<p>Returns the direction of the line, true if inverted</p> Source code in <code>model/line_2d.py</code> <pre><code>def direction(self, point, is_endpoint=False):\n    \"\"\"Returns the direction of the line, true if inverted\"\"\"\n    if is_endpoint:\n        return point == self.p1\n    else:\n        return point == self.p2\n</code></pre>"},{"location":"entities/#CAD_Sketcher.model.types.SlvsLine2D.normal","title":"<code>normal(position=None)</code>","text":"<p>Returns vector perpendicular to line, position is ignored</p> Source code in <code>model/line_2d.py</code> <pre><code>def normal(self, position=None):\n    \"\"\"Returns vector perpendicular to line, position is ignored\"\"\"\n    mat_rot = Matrix.Rotation(-math.pi / 2, 2, \"Z\")\n    nm = self.direction_vec()\n    nm.rotate(mat_rot)\n    return nm\n</code></pre>"},{"location":"entities/#CAD_Sketcher.model.types.SlvsLine2D.orientation","title":"<code>orientation()</code>","text":"<p>Return the orientation of the line in 3d space</p> Source code in <code>model/line_2d.py</code> <pre><code>def orientation(self):\n    \"\"\"Return the orientation of the line in 3d space\"\"\"\n    return (self.p2.location - self.p1.location).normalized()\n</code></pre>"},{"location":"entities/#CAD_Sketcher.model.types.SlvsLine2D.project_point","title":"<code>project_point(coords)</code>","text":"<p>Projects a point onto the line</p> Source code in <code>model/line_2d.py</code> <pre><code>def project_point(self, coords):\n    \"\"\"Projects a point onto the line\"\"\"\n    dir_vec = self.direction_vec()\n    p1 = self.p1.co\n\n    local_co = coords - p1\n    return local_co.project(dir_vec) + p1\n</code></pre>"},{"location":"entities/#CAD_Sketcher.model.types.SlvsArc.angle","title":"<code>angle</code>  <code>property</code>","text":"<p>Returns an angle in radians from zero to 2*PI</p>"},{"location":"entities/#CAD_Sketcher.model.types.SlvsArc.connection_angle","title":"<code>connection_angle(other, connection_point=None, **kwargs)</code>","text":"<p>Returns the angle at the connection point between the two entities or None if they're either not connected or not in 2d space</p> <p>You may use <code>connection_point</code> in order to remove ambiguity in case multiple intersections point exist with other entity.</p> <p><code>kwargs</code> key values are propagated to other <code>get_connection_point</code> functions</p> Source code in <code>model/arc.py</code> <pre><code>def connection_angle(self, other, connection_point=None, **kwargs):\n    \"\"\"Returns the angle at the connection point between the two entities\n    or None if they're either not connected or not in 2d space\n\n    You may use `connection_point` in order to remove ambiguity in case\n    multiple intersections point exist with other entity.\n\n    `kwargs` key values are propagated to other `get_connection_point` functions\n    \"\"\"\n\n    point = connection_point or get_connection_point(self, other)\n\n    if not point:\n        return None\n    if self.is_3d() or other.is_3d():\n        return None\n\n    def _get_tangent(arc, point):\n        local_co = point.co - arc.ct.co\n        angle = range_2pi(math.atan2(local_co.y, local_co.x))\n        mat_rot = Matrix.Rotation(angle, 2, \"Z\")\n        tangent = Vector((0, 1))\n        tangent.rotate(mat_rot)\n        invert = arc.direction(point)\n        if invert:\n            tangent *= -1\n        return tangent\n\n    # Get directions\n    directions = []\n    for entity in (self, other):\n        if entity.is_curve():\n            directions.append(_get_tangent(entity, point))\n        else:\n            directions.append(\n                entity.direction_vec()\n                if entity.direction(point)\n                else entity.direction_vec() * (-1)\n            )\n\n    dir1, dir2 = directions\n    return dir1.angle_signed(dir2)\n</code></pre>"},{"location":"entities/#CAD_Sketcher.model.types.SlvsArc.direction","title":"<code>direction(point, is_endpoint=False)</code>","text":"<p>Returns the direction of the arc, true if inverted</p> Source code in <code>model/arc.py</code> <pre><code>def direction(self, point, is_endpoint=False):\n    \"\"\"Returns the direction of the arc, true if inverted\"\"\"\n    if is_endpoint:\n        return point == self.start\n    return point == self.end\n</code></pre>"},{"location":"entities/#CAD_Sketcher.model.types.SlvsArc.normal","title":"<code>normal(position=None)</code>","text":"<p>Return the normal vector at a given position</p> Source code in <code>model/arc.py</code> <pre><code>def normal(self, position: Vector = None):\n    \"\"\"Return the normal vector at a given position\"\"\"\n\n    normal = position - self.ct.co\n    return normal.normalized()\n</code></pre>"},{"location":"entities/#CAD_Sketcher.model.types.SlvsArc.project_point","title":"<code>project_point(coords)</code>","text":"<p>Projects a point onto the arc</p> Source code in <code>model/arc.py</code> <pre><code>def project_point(self, coords):\n    \"\"\"Projects a point onto the arc\"\"\"\n    local_co = coords - self.ct.co\n    angle = range_2pi(math.atan2(local_co[1], local_co[0]))\n    return self.point_on_curve(angle, relative=False)\n</code></pre>"},{"location":"getting_started/","title":"Getting started","text":"<p>This guide takes you through the first steps in order to get familiar with the extension.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Download the Latest Release of the extension and install it from the \"Get Extensions\" tab in blender's preferences. See the installation guide if you have trouble installing the extension.</p>"},{"location":"getting_started/#create-a-sketch","title":"Create a Sketch","text":"<p>In the 3d Viewport open the sidebar (you can show it from the menu view-&gt;sidebar or by pressing the 'N' key) and change to the \"Sketcher\" tab. Press the button  \"Add Sketch\" and pick one of the origin planes that appears. The newly created sketch will then be activated and any geometry that is drawn will belong to it. The sketch can be exited and re-activated at any time by simply pressing the \"Leave Sketch\" button.</p>"},{"location":"getting_started/#add-some-geometry","title":"Add some Geometry","text":"<p>While a sketch is active switch to the \"Add Circle\" Workspacetool. Now hover the sketch's origin point, click it and move the mouse away, click again to confirm.</p>"},{"location":"getting_started/#add-constraints","title":"Add Constraints","text":"<p>Switch back to the Selection Tool, by pressing ESC. Make sure nothing is selected by pressing ESC again or by clicking into empty space while the selection tool is active. Now select the circle and click the button in the sidebar to add a diameter constraint.</p>"},{"location":"getting_started/#convert","title":"Convert","text":"<p>While the sketch is still active, select a convert method from the sidebar, then exit the sketch.</p>"},{"location":"getting_started/#edit-and-update","title":"Edit and Update","text":"<p>Re-activate the sketch from the sketch selector. Click the diameter constraint and enter a value. Switch to the rectangle tool and draw a rectangle around the circle.</p>"},{"location":"getting_started/#add-dimensions","title":"Add Dimensions","text":"<p>Now also give the rectangle exact dimensions by selecting a line and a point on the opposite side and clicking the distance button in the sidebar. Do that again for in the other direction.</p>"},{"location":"getting_started/#add-construction-geometry","title":"Add Construction Geometry","text":"<p>Note that the rectangle still hasn't a defined position. To fix that add a line between two edge points, mark it as construction and add a midpoint constraint between that line and the sketch origin.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"Extension ZIP FileLegacy addonGit <ul> <li>Download the ZIP archive from github (ensure it's a ZIP Archive, on Mac you might have to repack as it gets unzipped automatically)</li> <li>Open Blender and go to: Edit &gt; Preferences &gt; Get Extensions &gt; Extension Settings (Arrow in the top right corner) &gt; Press \"Install from Disk...\" button</li> <li>Browse to the location of the ZIP and select it, then press \"Install from Disk\"</li> </ul> <ul> <li>Download the ZIP archive from github (ensure it's a ZIP Archive, on Mac you might have to repack as it gets unzipped automatically)</li> <li>Open Blender and go to: Edit &gt; Preferences &gt; Add-ons &gt; Press \"Install...\" button</li> <li>Browse to the location of the ZIP and select it, then press \"Install Add-on\"</li> <li>Enable the addon by pressing the checkbox</li> </ul> <p>You can get the latest state of the addon and easily update it with git</p> <ul> <li>Get Git</li> <li>In Blender, add the scripts-path under Preferences-&gt;File Paths-&gt;Script Directories-&gt;Add (e.g. ~/blender_scripts)</li> <li> <p>Open your scripts_folder</p> <pre><code>cd ~/blender_scripts\n</code></pre> </li> <li> <p>Create an addons folder     <pre><code>mkdir addons\ncd addons\n</code></pre></p> </li> <li>Clone the addon repository     <pre><code>git clone https://github.com/hlorus/CAD_Sketcher.git\n</code></pre></li> <li>Blender will now automatically load addons from that path</li> </ul>"},{"location":"installation/#dependency-installation","title":"Dependency installation","text":"<p>CAD Sketcher heavily depends on the solvespace python module and won't be functional without it.</p> <p>Once the 3D View CAD Sketcher plugin is installed check its preferences for the \"Solver Module\" tab to see if the module is already available, otherwise follow one of the guides below.</p> Blender 4.2 ExtensionInstall from PIPInstall from local file <ul> <li>If you install CAD Skecther as a Blender Extension you can skip this step</li> </ul> <ul> <li>Press \"Install from PIP\"</li> <li>Wait for the process to finish</li> </ul> <ul> <li>Download the appropriate *.whl file here (make sure the python version matches the one from your blender installation)</li> <li>Choose the file in the filepath selector</li> <li>Press \"Install from local File\"</li> </ul>"},{"location":"installation/#extra-step-on-mac-os","title":"Extra step on Mac OS:","text":"<p>Due to an ongoing Blender bug, Mac OS users with Metal need to change their GPU Backend to OpenGL: Edit &gt; Preferences &gt; System &gt; GPU Backend &gt; Select \"OpenGL\". Remember to restart Blender after this.</p>"},{"location":"installation/#installation-fails","title":"Installation fails","text":"<p>There are multiple reasons why the installation might fail. Try the following:</p> <ul> <li>If you're on windows start blender as administrator when installing the dependency</li> <li>If you've installed blender through a package manager try again with a version from blender.org</li> <li>Check the application's output in the system console for any warnings or hints to find out why it's failing</li> <li>Blender can be installed through package managers, installing external python packages with such installations might not be possible. Try to use the extension with Blender installed from the official website.</li> <li>Ask for help</li> </ul>"},{"location":"installation/#updating","title":"Updating","text":"ManualGit <ul> <li>Delete the old version from the addons/extensions list under Edit &gt; Preferences &gt; Add-ons/Get Extensions</li> <li>Simply redo the installation steps with the latest addon version</li> </ul> <p>If you've cloned the addon with git you can easily update it:</p> <ul> <li>Open the addon folder in a terminal     <pre><code>cd ~/BLENDER_SCRIPTS_PATH/CAD_Sketcher\n</code></pre></li> <li>Pull the changes     <pre><code>git pull\n</code></pre></li> </ul>"},{"location":"integration/","title":"Integration","text":"<p>The geometry that is used in the extension isn't native blender geometry, that means blender doesn't know anything about it and native tools cannot work with it. So in order to further process drawn shapes they have to be converted to a native type first.</p> <p>INFO: There are some limitations to keep in mind when converting.</p>"},{"location":"integration/#convert-types","title":"Convert Types","text":"<p>When a sketch is active you can choose the convert type for it in the sidebar. By default this is set to None which means no native geometry will be created.</p> <p>INFO: Setting this to something other than None will disable the visibility of the sketch so that it will only show when it's active</p>"},{"location":"integration/#bezier-converter","title":"Bezier Converter","text":"<p>Converts the sketch to a bezier curve.</p>"},{"location":"integration/#mesh-converter","title":"Mesh Converter","text":"<p>Converts the sketch to a mesh. This doesn't convert to mesh directly but rather uses the bezier converter and the native to_mesh() function behind the scene.</p>"},{"location":"integration/#fill-shape","title":"Fill Shape","text":"<p>Some converters support the Fill Shape setting. When this isn't set the resulting geometry won't have surfaces at all but rather just edges.</p> <p>INFO: The setting toggles the bezier's fill_mode option between None and Front</p>"},{"location":"integration/#limitations","title":"Limitations","text":""},{"location":"integration/#3d-geometry","title":"3D Geometry","text":"<p>Conversion requires a sketch, the extension currently doesn't support creating 3D sketches and is therefor limited to the conversion of 2D entities.</p>"},{"location":"integration/#non-persistent-geometry","title":"Non-Persistent Geometry","text":"<p>The output geometry will be re-generated each time a sketch is deactivated. Converters don't take any modifications that are done after the conversion into account.</p> <p>INFO: Indices of created geometry elements aren't persistent. Referencing such elements isn't currently supported.</p> <p>In order to further process geometry after the conversion make sure you do this in a procedural way, otherwise things might break when editing the sketch.</p>"},{"location":"integration/#path-connections","title":"Path Connections","text":"<p>Converters parse the geometry depending on shared start-/endpoints, connections created with coincident constraints or overlaps between entities aren't interpreted as a connection.</p>"},{"location":"integration/#precision","title":"Precision","text":"<p>Bezier curves cannot exactly represent a circle. Converted curves are only an approximation to an exact arc or circle. Converted meshes also suffer from that error since the mesh convert type is currently based on the bezier converter.</p>"},{"location":"integration/#best-practices","title":"Best Practices","text":"<p>To avoid running into such limitations try to follow these practices:</p> <ul> <li>Connect entities by sharing a start-/endpoint, avoid using the coincident constraint to connect entities that are part of a path that you intend to later convert.</li> <li>Use the construction option whenever you create geometry that you don't intend to convert.</li> <li>If you have alot of construction geometry create a dedicated sketch that is used for construction only. Then create another sketch on the same workplane and reference entities from the construction sketch.</li> <li>If the Fill Shape option is set make sure the drawn shape is a closed path and that multiple closed paths don't overlap each other.</li> </ul>"},{"location":"interaction_system/","title":"Interaction system","text":"<p>The focus of the extension lies on different aspects than blender itself. Extension tools usually work on one specific entity or between a few entities where the order of selection matters. As the existing system of selection isn't ideal in this context the extension defines a generic interaction system which allows for a powerful and flexible workflow.</p>"},{"location":"interaction_system/#stateful-operations","title":"Stateful Operations","text":"<p>Most tools in the extension are implemented as stateful tools. In this context a state represents one target like a selection or a value. When running a tool you will iterate through these states until all states have valid input.</p> <p>Let's take the \"Add Circle\" tool as an example. Since a circle is represented by its center and radius the tool will have two states. One to define the center element and one to set the radius.</p>"},{"location":"interaction_system/#state-types","title":"State Types","text":"<p>A state can have two different kind of targets:</p> <ul> <li>Pointer</li> </ul> <p>A pointer target is best described as a selection. Pointer states will prompt the user to select an element of the according type.</p> <ul> <li>Property</li> </ul> <p>A property target simply represents a value of some kind like an integer or a float  or a set of values to represent something like a location.</p> <p> A state can however define both of those targets. In that case the property will be used to create a new element to satisfy the pointer target. This is often used to be able to place a new point at the mouse location when nothing is hovered but pick an existing point if one is hovered.</p>"},{"location":"interaction_system/#selection-vs-action","title":"Selection vs Action","text":"<p>To be as flexible as possible the interaction system allows to work in different paradigms which can also be freely mixed. Those are:</p> <ul> <li> <p>Select -&gt; Invoke Operation   (The standard way to work in blender) </p> </li> <li> <p>Invoke Operation -&gt; Select </p> </li> <li> <p>Partial Select -&gt; Invoke Operation -&gt; Select rest (Or set Parameters) </p> </li> </ul>"},{"location":"interaction_system/#numerical-edit","title":"Numerical Edit","text":"<p>In order to precisely edit a states property, it's possible to edit values directly by entering numbers. When the stateproperty is a set of multiple values (e.g. XYZ Location) they will be treated as sub-states, meaning you can iterate (TAB) through them and enter values sequentially.</p>"},{"location":"interaction_system/#description","title":"Description","text":"<p>When learning how a new tool works it's best to take a look at its tooltip, this will list the different states of the tool. For pointer states this will additionally display the accepted types that can be picked.</p> <p></p> <p></p> <p>While running an operation the statusbar will display that information for the currently active state.</p> <p></p>"},{"location":"interaction_system/#immediate-execution","title":"Immediate Execution","text":"<p>Most tools support immediate execution which will invoke the tools operations when switching to it and a valid selection is given.</p> <p>Note that the execution is only triggered when a tool is invoked by its shortcut.</p> <p></p>"},{"location":"reference/","title":"Reference","text":"<p>               Bases: <code>PropertyGroup</code></p> <p>The base structure for CAD Sketcher</p> Source code in <code>model/group_sketcher.py</code> <pre><code>class SketcherProps(PropertyGroup):\n    \"\"\"The base structure for CAD Sketcher\"\"\"\n\n    entities: PointerProperty(type=SlvsEntities)\n    constraints: PointerProperty(type=SlvsConstraints)\n    show_origin: BoolProperty(name=\"Show Origin Entities\")\n    use_construction: BoolProperty(\n        name=\"Construction Mode\",\n        description=\"Draw all subsequent entities in construction mode\",\n        default=False,\n        options={\"SKIP_SAVE\"},\n        update=update_cb,\n    )\n    selectable_constraints: BoolProperty(\n        name=\"Constraints Selectability\",\n        default=True,\n        options={\"SKIP_SAVE\"},\n        update=update_cb,\n    )\n\n    version: IntVectorProperty(\n        name=\"Extension Version\",\n        description=\"CAD Sketcher extension version this scene was saved with\",\n    )\n\n    # This is needed for the sketches ui list\n    ui_active_sketch: IntProperty()\n\n    @property\n    def all(self) -&gt; Generator[Union[SlvsGenericEntity, SlvsConstraints], None, None]:\n        \"\"\"Iterate over entities and constraints of every type\"\"\"\n        for entity in self.entities.all:\n            yield entity\n        for constraint in self.constraints.all:\n            yield constraint\n\n    def solve(self, context: Context):\n        return solve_system(context)\n\n    def purge_stale_data(self):\n        global_data.hover = -1\n        global_data.selected.clear()\n        global_data.batches.clear()\n        for e in self.entities.all:\n            e.dirty = True\n</code></pre> <p>               Bases: <code>PropertyGroup</code></p> <p>Holds all Solvespace Entities</p> Source code in <code>model/group_entities.py</code> <pre><code>class SlvsEntities(PropertyGroup):\n    \"\"\"Holds all Solvespace Entities\"\"\"\n\n    @classmethod\n    def _type_index(cls, entity: SlvsGenericEntity) -&gt; int:\n        return _entity_types.index(type(entity))\n\n    def _set_index(self, entity: SlvsGenericEntity):\n        \"\"\"Create an index for the entity and assign it.\n        Index breakdown\n\n        | entity type index |  entity object index  |\n        |:-----------------:|:---------------------:|\n        |      4 bits       |       20 bits         |\n        |            total: 3 Bytes                 |\n        \"\"\"\n        type_index = self._type_index(entity)\n        sub_list = getattr(self, _entity_collections[type_index])\n\n        local_index = len(sub_list) - 1\n        # TODO: handle this case better\n        assert local_index &lt; math.pow(2, 20)\n        index = assemble_index(type_index, local_index)\n        entity.slvs_index = index\n        return index\n\n    @staticmethod\n    def _breakdown_index(index: int):\n        return breakdown_index(index)\n\n    @classmethod\n    def recalc_type_index(cls, entity):\n        _, local_index = cls._breakdown_index(entity.slvs_index)\n        type_index = cls._type_index(entity)\n        entity.slvs_index = type_index &lt;&lt; 20 | local_index\n\n    def type_from_index(self, index: int) -&gt; Type[SlvsGenericEntity]:\n        return type_from_index(index)\n\n    def collection_name_from_index(self, index: int):\n        if index &lt; 0:\n            return\n\n        type_index, _ = self._breakdown_index(index)\n        return _entity_collections[type_index]\n\n    def _get_list_and_index(self, index: int):\n        type_index, local_index = self._breakdown_index(index)\n        if type_index &lt; 0 or type_index &gt;= len(_entity_collections):\n            return None, local_index\n        return getattr(self, _entity_collections[type_index]), local_index\n\n    def get(self, index: int) -&gt; SlvsGenericEntity:\n        \"\"\"Get entity by index\n\n        Arguments:\n            index: The global index of the entity.\n\n        Returns:\n            SlvsGenericEntity: Entity with the given global index or None if not found.\n        \"\"\"\n        if index == -1:\n            return None\n        sub_list, i = self._get_list_and_index(index)\n        if not sub_list or i &gt;= len(sub_list):\n            return None\n        return sub_list[i]\n\n    def remove(self, index: int):\n        \"\"\"Remove entity by index\n\n        Arguments:\n            index: The global index of the entity.\n        \"\"\"\n        assert isinstance(index, int)\n\n        if self.get(index).origin:\n            return\n\n        entity_list, i = self._get_list_and_index(index)\n        entity_list.remove(i)\n\n        # Put last item to removed index and update all pointers to it\n        last_index = len(entity_list) - 1\n\n        if last_index &lt; 0:\n            return\n        if i &gt; last_index:\n            return\n\n        if not i == last_index:  # second last item was deleted\n            entity_list.move(last_index, i)\n\n        new_item = entity_list[i]\n        update_pointers(bpy.context.scene, new_item.slvs_index, index)\n        new_item.slvs_index = index\n\n    def _init_entity(self, entity, fixed, construction, index_reference, visible=True):\n        \"\"\"Initializes all shared entity properties\"\"\"\n\n        entity[\"fixed\"] = fixed\n        entity[\"construction\"] = construction\n        entity[\"visible\"] = visible\n\n        index = self._set_index(entity)\n\n        if index_reference:\n            return index\n        return entity\n\n    def add_point_3d(\n        self,\n        co: Union[Tuple[float, float, float], Vector],\n        fixed: bool = False,\n        construction: bool = False,\n        index_reference: bool = False,\n    ) -&gt; Union[SlvsPoint3D, int]:\n        \"\"\"Add a point in 3d space.\n\n        Arguments:\n            co: Location of the point in 3d space.\n\n        Returns:\n            SlvsPoint3D: The created point.\n        \"\"\"\n        if not hasattr(co, \"__len__\") or len(co) != 3:\n            raise TypeError(\"Argument co must be of length 3\")\n\n        p = self.points3D.add()\n        p[\"location\"] = Vector(co)\n        return self._init_entity(p, fixed, construction, index_reference)\n\n    def add_line_3d(\n        self,\n        p1: Union[SlvsPoint3D, int],\n        p2: Union[SlvsPoint3D, int],\n        fixed: bool = False,\n        construction: bool = False,\n        index_reference: bool = False,\n    ) -&gt; SlvsLine3D:\n        \"\"\"Add a line in 3d space.\n\n        Arguments:\n            p1: Line's startpoint.\n            p2: Line's endpoint.\n\n        Returns:\n            SlvsLine3D: The created line.\n        \"\"\"\n        line = self.lines3D.add()\n        line[\"p1_i\"] = p1 if isinstance(p1, int) else p1.slvs_index\n        line[\"p2_i\"] = p2 if isinstance(p2, int) else p2.slvs_index\n\n        return self._init_entity(line, fixed, construction, index_reference)\n\n    def add_normal_3d(\n        self,\n        quat: Tuple[float, float, float, float],\n        fixed: bool = False,\n        construction: bool = False,\n        index_reference: bool = False,\n    ) -&gt; SlvsNormal3D:\n        \"\"\"Add a normal in 3d space.\n\n        Arguments:\n            quat: Quaternion which describes the orientation.\n\n        Returns:\n            SlvsNormal3D: The created normal.\n        \"\"\"\n        nm = self.normals3D.add()\n        nm[\"orientation\"] = Quaternion(quat)\n\n        return self._init_entity(nm, fixed, construction, index_reference)\n\n    def add_workplane(\n        self,\n        p1: SlvsPoint3D,\n        nm: SlvsGenericEntity,\n        fixed: bool = False,\n        construction: bool = False,\n        index_reference: bool = False,\n    ) -&gt; SlvsWorkplane:\n        \"\"\"Add a workplane.\n\n        Arguments:\n            p1: Workplane's originpoint.\n            nm: Workplane's normal.\n\n        Returns:\n            SlvsWorkplane: The created workplane.\n        \"\"\"\n        wp = self.workplanes.add()\n        wp[\"p1_i\"] = p1 if isinstance(p1, int) else p1.slvs_index\n        wp[\"nm_i\"] = nm if isinstance(nm, int) else nm.slvs_index\n\n        return self._init_entity(wp, fixed, construction, index_reference)\n\n    def add_sketch(\n        self,\n        wp: SlvsWorkplane,\n        fixed: bool = False,\n        construction: bool = False,\n        index_reference: bool = False,\n    ) -&gt; SlvsSketch:\n        \"\"\"Add a Sketch.\n\n        Arguments:\n            wp: Sketch's workplane.\n\n        Returns:\n            SlvsSketch: The created sketch.\n        \"\"\"\n        sketch = self.sketches.add()\n        sketch[\"wp_i\"] = wp if isinstance(wp, int) else wp.slvs_index\n\n        retval = self._init_entity(sketch, fixed, construction, index_reference)\n        index = retval if index_reference else retval.slvs_index\n        _, i = self._breakdown_index(index)\n        sketch.name = \"Sketch\"\n        return retval\n\n    def add_point_2d(\n        self,\n        co: Tuple[float, float],\n        sketch: SlvsSketch,\n        fixed: bool = False,\n        construction: bool = False,\n        index_reference: bool = False,\n    ) -&gt; SlvsPoint2D:\n        \"\"\"Add a point in 2d space.\n\n        Arguments:\n            co: Coordinates of the point on the workplane.\n            sketch: The sketch this point belongs to.\n\n        Returns:\n            SlvsPoint2D: The created point.\n        \"\"\"\n        p = self.points2D.add()\n        p[\"co\"] = Vector(co)\n        p[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n\n        return self._init_entity(p, fixed, construction, index_reference)\n\n    def add_line_2d(\n        self,\n        p1: SlvsPoint2D,\n        p2: SlvsPoint2D,\n        sketch: SlvsSketch,\n        fixed: bool = False,\n        construction: bool = False,\n        index_reference: bool = False,\n    ) -&gt; SlvsLine2D:\n        \"\"\"Add a line in 2d space.\n\n        Arguments:\n            p1: Line's startpoint.\n            p2: Line's endpoint.\n            sketch: The sketch this line belongs to.\n\n        Returns:\n            SlvsLine2D: The created line.\n        \"\"\"\n        line = self.lines2D.add()\n        line[\"p1_i\"] = p1 if isinstance(p1, int) else p1.slvs_index\n        line[\"p2_i\"] = p2 if isinstance(p2, int) else p2.slvs_index\n        line[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n\n        return self._init_entity(line, fixed, construction, index_reference)\n\n    def add_normal_2d(\n        self,\n        sketch: SlvsSketch,\n        fixed: bool = False,\n        construction: bool = False,\n        index_reference: bool = False,\n    ) -&gt; SlvsNormal2D:\n        \"\"\"Add a normal in 2d space.\n\n        Arguments:\n            sketch: The sketch this normal belongs to.\n\n        Returns:\n            SlvsNormal2D: The created normal.\n        \"\"\"\n        nm = self.normals2D.add()\n        nm[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n\n        return self._init_entity(nm, fixed, construction, index_reference)\n\n    def add_arc(\n        self,\n        nm: SlvsNormal2D,\n        ct: SlvsPoint2D,\n        p1: SlvsPoint2D,\n        p2: SlvsPoint2D,\n        sketch: SlvsSketch,\n        invert: bool = False,\n        fixed: bool = False,\n        construction: bool = False,\n        index_reference: bool = False,\n    ) -&gt; SlvsArc:\n        \"\"\"Add an arc in 2d space.\n\n        Arguments:\n            ct: Arc's centerpoint.\n            p1: Arc's startpoint.\n            p2: Arc's endpoint.\n            sketch: The sketch this arc belongs to.\n            nm: Arc's normal.\n\n        Returns:\n            SlvsArc: The created arc.\n        \"\"\"\n        arc = self.arcs.add()\n        arc[\"nm_i\"] = nm if isinstance(nm, int) else nm.slvs_index\n        arc[\"ct_i\"] = ct if isinstance(ct, int) else ct.slvs_index\n        arc[\"p1_i\"] = p1 if isinstance(p1, int) else p1.slvs_index\n        arc[\"p2_i\"] = p2 if isinstance(p2, int) else p2.slvs_index\n        arc[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n        arc[\"invert_direction\"] = invert\n\n        return self._init_entity(arc, fixed, construction, index_reference)\n\n    def add_circle(\n        self,\n        nm: SlvsNormal2D,\n        ct: SlvsPoint2D,\n        radius: float,\n        sketch: SlvsSketch,\n        fixed: bool = False,\n        construction: bool = False,\n        index_reference: bool = False,\n    ) -&gt; SlvsCircle:\n        \"\"\"Add a circle in 2d space.\n\n        Arguments:\n            ct: Circle's centerpoint.\n            radius: Circle's radius.\n            sketch: The sketch this circle belongs to.\n            nm: Circle's normal.\n\n        Returns:\n            SlvsCircle: The created circle.\n        \"\"\"\n        c = self.circles.add()\n        c[\"nm_i\"] = nm if isinstance(nm, int) else nm.slvs_index\n        c[\"ct_i\"] = ct if isinstance(ct, int) else ct.slvs_index\n        c[\"radius\"] = float(radius)\n        c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n\n        return self._init_entity(c, fixed, construction, index_reference)\n\n    @property\n    def all(self):\n        for coll_name in _entity_collections:\n            entity_coll = getattr(self, coll_name)\n            for entity in entity_coll:\n                yield entity\n\n    @property\n    def selected(self):\n        \"\"\"Return all selected entities, might include inactive entities\"\"\"\n        context = bpy.context\n        items = []\n        for index in global_data.selected:\n            if index is None:\n                continue\n            entity = self.get(index)\n            items.append(entity)\n        return [e for e in items if e.is_selectable(context)]\n\n    @property\n    def selected_all(self):\n        \"\"\"Return all selected entities, might include invisible entities\"\"\"\n        context = bpy.context\n        items = []\n        for index in global_data.selected:\n            if index is None:\n                continue\n            entity = self.get(index)\n            items.append(entity)\n        return [e for e in items if e.selected]\n\n    @property\n    def selected_active(self):\n        \"\"\"Returns all selected and active entities\"\"\"\n        context = bpy.context\n        active_sketch = context.scene.sketcher.active_sketch\n        return [e for e in self.selected if e.is_active(active_sketch)]\n\n    def ensure_origin_elements(self, context):\n        def set_origin_props(e):\n            e.fixed = True\n            e.origin = True\n\n        sse = context.scene.sketcher.entities\n        # origin\n        if not self.origin:\n            p = sse.add_point_3d((0.0, 0.0, 0.0))\n            set_origin_props(p)\n            p.name = \"OriginPoint3D\"\n            self.origin = p\n\n        # axis\n        pi_2 = QUARTER_TURN\n        for label, name, angles in zip(\n            (\"OriginAxisX\", \"OriginAxisY\", \"OriginAxisZ\"),\n            (\"origin_axis_X\", \"origin_axis_Y\", \"origin_axis_Z\"),\n            (Euler((pi_2, 0.0, pi_2)), Euler((pi_2, 0.0, 0.0)), Euler()),\n        ):\n            if getattr(self, name):\n                continue\n            nm = sse.add_normal_3d(Euler(angles).to_quaternion())\n            set_origin_props(nm)\n            setattr(self, name, nm)\n            nm.name = label\n\n        # workplanes\n        for label, nm_name, wp_name in (\n            (\"OriginWorkplaneYZ\", \"origin_axis_X\", \"origin_plane_YZ\"),\n            (\"OriginWorkplaneXZ\", \"origin_axis_Y\", \"origin_plane_XZ\"),\n            (\"OriginWorkplaneXY\", \"origin_axis_Z\", \"origin_plane_XY\"),\n        ):\n            if getattr(self, wp_name):\n                continue\n            wp = sse.add_workplane(self.origin, getattr(self, nm_name))\n            set_origin_props(wp)\n            setattr(self, wp_name, wp)\n            wp.name = label\n\n    def collection_offsets(self):\n        offsets = {}\n        for i, key in enumerate(_entity_collections):\n            offsets[i] = len(getattr(self, key))\n        return offsets\n</code></pre> <p>               Bases: <code>PropertyGroup</code></p> Source code in <code>model/group_constraints.py</code> <pre><code>class SlvsConstraints(PropertyGroup):\n\n    _dimensional_constraints = (\n        SlvsDistance,\n        SlvsAngle,\n        SlvsDiameter,\n    )\n\n    _geometric_constraints = (\n        SlvsCoincident,\n        SlvsEqual,\n        SlvsParallel,\n        SlvsHorizontal,\n        SlvsVertical,\n        SlvsTangent,\n        SlvsMidpoint,\n        SlvsPerpendicular,\n        SlvsRatio,\n    )\n\n    _constraints = (\n        SlvsCoincident,\n        SlvsEqual,\n        SlvsDistance,\n        SlvsAngle,\n        SlvsDiameter,\n        SlvsParallel,\n        SlvsHorizontal,\n        SlvsVertical,\n        SlvsTangent,\n        SlvsMidpoint,\n        SlvsPerpendicular,\n        SlvsRatio,\n    )\n\n    __annotations__ = {\n        cls.type.lower(): CollectionProperty(type=cls) for cls in _constraints\n    }\n\n    @classmethod\n    def cls_from_type(cls, type: str):\n        for constraint in cls._constraints:\n            if type == constraint.type:\n                return constraint\n        return None\n\n    def new_from_type(self, type: str) -&gt; GenericConstraint:\n        \"\"\"Create a constraint by type.\n\n        Arguments:\n            type: Type of the constraint to be created.\n        \"\"\"\n        name = type.lower()\n        constraint_list = getattr(self, name)\n        return constraint_list.add()\n\n    def get_lists(self):\n        lists = []\n        for entity_list in self.rna_type.properties:\n            name = entity_list.identifier\n            if name in (\"name\", \"rna_type\"):\n                continue\n            lists.append(getattr(self, name))\n        return lists\n\n    def get_list(self, type: str):\n        return getattr(self, type.lower())\n\n    def get_from_type_index(self, type: str, index: int) -&gt; GenericConstraint:\n        \"\"\"Get constraint by type and local index.\n\n        Arguments:\n            type: Constraint's type.\n            index: Constraint's local index.\n\n        Returns:\n            GenericConstraint: Constraint with the given type and index or None if not found.\n        \"\"\"\n        list = getattr(self, type.lower())\n        if not list or index &gt;= len(list):\n            return None\n        return list[index]\n\n    def get_index(self, constr: GenericConstraint) -&gt; int:\n        \"\"\"Get the index of a constraint in its collection.\n\n        Arguments:\n            constr: Constraint to get the index for.\n\n        Returns:\n            int: Index of the constraint or -1 if not found.\n        \"\"\"\n        list = getattr(self, constr.type.lower())\n        for i, item in enumerate(list):\n            if item == constr:\n                return i\n        return -1\n\n    def remove(self, constr: GenericConstraint):\n        \"\"\"Remove a constraint.\n\n        Arguments:\n            constr: Constraint to be removed.\n        \"\"\"\n        i = self.get_index(constr)\n        self.get_list(constr.type).remove(i)\n\n    @property\n    def dimensional(self):\n        for constraint_type in self._dimensional_constraints:\n            for entity in self.get_list(constraint_type.type):\n                yield entity\n\n    @property\n    def geometric(self):\n        for constraint_type in self._geometric_constraints:\n            for entity in self.get_list(constraint_type.type):\n                yield entity\n\n    @property\n    def all(self):\n        for entity_list in self.get_lists():\n            for entity in entity_list:\n                yield entity\n\n    def add_coincident(\n        self,\n        entity1: SlvsGenericEntity,\n        entity2: SlvsGenericEntity,\n        sketch: SlvsSketch = None,\n    ) -&gt; SlvsCoincident:\n        \"\"\"Add a coincident constraint.\n\n        Arguments:\n            entity1: -\n            entity2: -\n            sketch: The sketch this constraint belongs to.\n\n        Returns:\n            SlvsCoincident: The created constraint.\n        \"\"\"\n\n        if all([e.is_point() for e in (entity1, entity2)]):\n            # TODO: Implicitly merge points\n            return\n\n        c = self.coincident.add()\n        c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n        c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n        if sketch:\n            c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n        return c\n\n    def add_equal(\n        self,\n        entity1: SlvsGenericEntity,\n        entity2: SlvsGenericEntity,\n        sketch: Union[SlvsSketch, None] = None,\n    ) -&gt; SlvsEqual:\n        \"\"\"Add an equal constraint.\n\n        Arguments:\n            entity1: -\n            entity2: -\n            sketch: The sketch this constraint belongs to.\n\n        Returns:\n            SlvsEqual: The created constraint.\n        \"\"\"\n        c = self.equal.add()\n        c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n        c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n        if sketch is not None:\n            c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n        return c\n\n    def add_distance(\n        self,\n        entity1: SlvsGenericEntity,\n        entity2: Union[None, SlvsGenericEntity],\n        sketch: Union[SlvsSketch, None] = None,\n        init: bool = False,\n        **settings,\n    ) -&gt; SlvsDistance:\n        \"\"\"Add a distance constraint.\n\n        Arguments:\n            entity1: -\n            entity2: -\n            sketch: The sketch this constraint belongs to.\n            init: Initialize the constraint based on the given entities.\n\n        Returns:\n            SlvsDistance: The created constraint.\n        \"\"\"\n        c = self.distance.add()\n        c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n\n        if entity2 is not None:\n            c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n        if sketch is not None:\n            c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n        if init:\n            c.assign_init_props(**settings)\n        else:\n            c.assign_settings(**settings)\n        return c\n\n    def add_angle(\n        self,\n        entity1: SlvsGenericEntity,\n        entity2: SlvsGenericEntity,\n        sketch: SlvsSketch = None,\n        init: bool = False,\n        **settings,\n    ) -&gt; SlvsAngle:\n        \"\"\"Add an angle constraint.\n\n        Arguments:\n            entity1: -\n            entity2: -\n            sketch: The sketch this constraint belongs to.\n            init: Initialize the constraint based on the given entities.\n\n        Returns:\n            SlvsAngle: The created constraint.\n        \"\"\"\n        c = self.angle.add()\n        c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n        c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n        if sketch is not None:\n            c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n        if init:\n            c.assign_init_props(**settings)\n        else:\n            c.assign_settings(**settings)\n        return c\n\n    def add_diameter(\n        self,\n        entity1: SlvsGenericEntity,\n        sketch: SlvsSketch = None,\n        init: bool = False,\n        **settings,\n    ) -&gt; SlvsDiameter:\n        \"\"\"Add a diameter constraint.\n\n        Arguments:\n            entity1: -\n            sketch: The sketch this constraint belongs to.\n            init: Initialize the constraint based on the given entities.\n\n        Returns:\n            SlvsDiameter: The created constraint.\n        \"\"\"\n        c = self.diameter.add()\n        c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n        if sketch:\n            c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n        if init:\n            c.assign_init_props(**settings)\n        else:\n            c.assign_settings(**settings)\n        return c\n\n    def add_parallel(\n        self,\n        entity1: SlvsGenericEntity,\n        entity2: SlvsGenericEntity,\n        sketch: Union[SlvsSketch, None] = None,\n    ) -&gt; SlvsParallel:\n        \"\"\"Add a parallel constraint.\n\n        Arguments:\n            entity1: -\n            entity2: -\n            sketch: The sketch this constraint belongs to.\n\n        Returns:\n            SlvsParallel: The created constraint.\n        \"\"\"\n        c = self.parallel.add()\n        c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n        c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n        if sketch is not None:\n            c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n        return c\n\n    def add_horizontal(\n        self,\n        entity1: SlvsGenericEntity,\n        entity2: SlvsGenericEntity = None,\n        sketch: Union[SlvsSketch, None] = None,\n    ) -&gt; SlvsHorizontal:\n        \"\"\"Add a horizontal constraint.\n\n        Arguments:\n            entity1: -\n            sketch: The sketch this constraint belongs to.\n\n        Returns:\n            SlvsHorizontal: The created constraint.\n        \"\"\"\n        c = self.horizontal.add()\n        c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n        if entity2 is not None:\n            c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n        if sketch is not None:\n            c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n        return c\n\n    def add_vertical(\n        self,\n        entity1: SlvsGenericEntity,\n        entity2: SlvsGenericEntity = None,\n        sketch: Union[SlvsSketch, None] = None,\n    ) -&gt; SlvsVertical:\n        \"\"\"Add a vertical constraint.\n\n        Arguments:\n            entity1: -\n            sketch: The sketch this constraint belongs to.\n\n        Returns:\n            SlvsVertical: The created constraint.\n        \"\"\"\n        c = self.vertical.add()\n        c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n        if entity2 is not None:\n            c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n        if sketch is not None:\n            c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n        return c\n\n    def add_tangent(\n        self,\n        entity1: SlvsGenericEntity,\n        entity2: SlvsGenericEntity,\n        sketch: Union[SlvsSketch, None] = None,\n    ) -&gt; SlvsTangent:\n        \"\"\"Add a tangent constraint.\n\n        Arguments:\n            entity1: -\n            entity2: -\n            sketch: The sketch this constraint belongs to.\n\n        Returns:\n            SlvsTangent: The created constraint.\n        \"\"\"\n        c = self.tangent.add()\n        c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n        c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n        if sketch is not None:\n            c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n        return c\n\n    def add_midpoint(\n        self,\n        entity1: SlvsGenericEntity,\n        entity2: SlvsGenericEntity,\n        sketch: Union[SlvsSketch, None] = None,\n    ) -&gt; SlvsMidpoint:\n        \"\"\"Add a midpoint constraint.\n\n        Arguments:\n            entity1: -\n            entity2: -\n            sketch: The sketch this constraint belongs to.\n\n        Returns:\n            SlvsMidpoint: The created constraint.\n        \"\"\"\n        c = self.midpoint.add()\n        c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n        c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n        if sketch is not None:\n            c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n        return c\n\n    def add_perpendicular(\n        self,\n        entity1: SlvsGenericEntity,\n        entity2: SlvsGenericEntity,\n        sketch: Union[SlvsSketch, None] = None,\n    ) -&gt; SlvsPerpendicular:\n        \"\"\"Add a perpendicular constraint.\n\n        Arguments:\n            entity1: -\n            entity2: -\n            sketch: The sketch this constraint belongs to.\n\n        Returns:\n            SlvsPerpendicular: The created constraint.\n        \"\"\"\n        c = self.perpendicular.add()\n        c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n        c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n        if sketch is not None:\n            c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n        return c\n\n    def add_ratio(\n        self,\n        entity1: SlvsGenericEntity,\n        entity2: SlvsGenericEntity,\n        sketch: Union[SlvsSketch, None] = None,\n        init: bool = False,\n        **settings,\n    ) -&gt; SlvsRatio:\n        \"\"\"Add a ratio constraint.\n\n        Arguments:\n            entity1: -\n            entity2: -\n            sketch: The sketch this constraint belongs to.\n            init: Initialize the constraint based on the given entities.\n\n        Returns:\n            SlvsRatio: The created constraint.\n        \"\"\"\n        c = self.ratio.add()\n        c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n        c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n        if sketch is not None:\n            c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n        if init:\n            c.assign_init_props(**settings)\n        else:\n            c.assign_settings(**settings)\n        return c\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SketcherProps.all","title":"<code>all: Generator[Union[SlvsGenericEntity, SlvsConstraints], None, None]</code>  <code>property</code>","text":"<p>Iterate over entities and constraints of every type</p>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsEntities.selected","title":"<code>selected</code>  <code>property</code>","text":"<p>Return all selected entities, might include inactive entities</p>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsEntities.selected_active","title":"<code>selected_active</code>  <code>property</code>","text":"<p>Returns all selected and active entities</p>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsEntities.selected_all","title":"<code>selected_all</code>  <code>property</code>","text":"<p>Return all selected entities, might include invisible entities</p>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsEntities.add_arc","title":"<code>add_arc(nm, ct, p1, p2, sketch, invert=False, fixed=False, construction=False, index_reference=False)</code>","text":"<p>Add an arc in 2d space.</p> <p>Parameters:</p> Name Type Description Default <code>ct</code> <code>SlvsPoint2D</code> <p>Arc's centerpoint.</p> required <code>p1</code> <code>SlvsPoint2D</code> <p>Arc's startpoint.</p> required <code>p2</code> <code>SlvsPoint2D</code> <p>Arc's endpoint.</p> required <code>sketch</code> <code>SlvsSketch</code> <p>The sketch this arc belongs to.</p> required <code>nm</code> <code>SlvsNormal2D</code> <p>Arc's normal.</p> required <p>Returns:</p> Name Type Description <code>SlvsArc</code> <code>SlvsArc</code> <p>The created arc.</p> Source code in <code>model/group_entities.py</code> <pre><code>def add_arc(\n    self,\n    nm: SlvsNormal2D,\n    ct: SlvsPoint2D,\n    p1: SlvsPoint2D,\n    p2: SlvsPoint2D,\n    sketch: SlvsSketch,\n    invert: bool = False,\n    fixed: bool = False,\n    construction: bool = False,\n    index_reference: bool = False,\n) -&gt; SlvsArc:\n    \"\"\"Add an arc in 2d space.\n\n    Arguments:\n        ct: Arc's centerpoint.\n        p1: Arc's startpoint.\n        p2: Arc's endpoint.\n        sketch: The sketch this arc belongs to.\n        nm: Arc's normal.\n\n    Returns:\n        SlvsArc: The created arc.\n    \"\"\"\n    arc = self.arcs.add()\n    arc[\"nm_i\"] = nm if isinstance(nm, int) else nm.slvs_index\n    arc[\"ct_i\"] = ct if isinstance(ct, int) else ct.slvs_index\n    arc[\"p1_i\"] = p1 if isinstance(p1, int) else p1.slvs_index\n    arc[\"p2_i\"] = p2 if isinstance(p2, int) else p2.slvs_index\n    arc[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n    arc[\"invert_direction\"] = invert\n\n    return self._init_entity(arc, fixed, construction, index_reference)\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsEntities.add_circle","title":"<code>add_circle(nm, ct, radius, sketch, fixed=False, construction=False, index_reference=False)</code>","text":"<p>Add a circle in 2d space.</p> <p>Parameters:</p> Name Type Description Default <code>ct</code> <code>SlvsPoint2D</code> <p>Circle's centerpoint.</p> required <code>radius</code> <code>float</code> <p>Circle's radius.</p> required <code>sketch</code> <code>SlvsSketch</code> <p>The sketch this circle belongs to.</p> required <code>nm</code> <code>SlvsNormal2D</code> <p>Circle's normal.</p> required <p>Returns:</p> Name Type Description <code>SlvsCircle</code> <code>SlvsCircle</code> <p>The created circle.</p> Source code in <code>model/group_entities.py</code> <pre><code>def add_circle(\n    self,\n    nm: SlvsNormal2D,\n    ct: SlvsPoint2D,\n    radius: float,\n    sketch: SlvsSketch,\n    fixed: bool = False,\n    construction: bool = False,\n    index_reference: bool = False,\n) -&gt; SlvsCircle:\n    \"\"\"Add a circle in 2d space.\n\n    Arguments:\n        ct: Circle's centerpoint.\n        radius: Circle's radius.\n        sketch: The sketch this circle belongs to.\n        nm: Circle's normal.\n\n    Returns:\n        SlvsCircle: The created circle.\n    \"\"\"\n    c = self.circles.add()\n    c[\"nm_i\"] = nm if isinstance(nm, int) else nm.slvs_index\n    c[\"ct_i\"] = ct if isinstance(ct, int) else ct.slvs_index\n    c[\"radius\"] = float(radius)\n    c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n\n    return self._init_entity(c, fixed, construction, index_reference)\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsEntities.add_line_2d","title":"<code>add_line_2d(p1, p2, sketch, fixed=False, construction=False, index_reference=False)</code>","text":"<p>Add a line in 2d space.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>SlvsPoint2D</code> <p>Line's startpoint.</p> required <code>p2</code> <code>SlvsPoint2D</code> <p>Line's endpoint.</p> required <code>sketch</code> <code>SlvsSketch</code> <p>The sketch this line belongs to.</p> required <p>Returns:</p> Name Type Description <code>SlvsLine2D</code> <code>SlvsLine2D</code> <p>The created line.</p> Source code in <code>model/group_entities.py</code> <pre><code>def add_line_2d(\n    self,\n    p1: SlvsPoint2D,\n    p2: SlvsPoint2D,\n    sketch: SlvsSketch,\n    fixed: bool = False,\n    construction: bool = False,\n    index_reference: bool = False,\n) -&gt; SlvsLine2D:\n    \"\"\"Add a line in 2d space.\n\n    Arguments:\n        p1: Line's startpoint.\n        p2: Line's endpoint.\n        sketch: The sketch this line belongs to.\n\n    Returns:\n        SlvsLine2D: The created line.\n    \"\"\"\n    line = self.lines2D.add()\n    line[\"p1_i\"] = p1 if isinstance(p1, int) else p1.slvs_index\n    line[\"p2_i\"] = p2 if isinstance(p2, int) else p2.slvs_index\n    line[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n\n    return self._init_entity(line, fixed, construction, index_reference)\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsEntities.add_line_3d","title":"<code>add_line_3d(p1, p2, fixed=False, construction=False, index_reference=False)</code>","text":"<p>Add a line in 3d space.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>Union[SlvsPoint3D, int]</code> <p>Line's startpoint.</p> required <code>p2</code> <code>Union[SlvsPoint3D, int]</code> <p>Line's endpoint.</p> required <p>Returns:</p> Name Type Description <code>SlvsLine3D</code> <code>SlvsLine3D</code> <p>The created line.</p> Source code in <code>model/group_entities.py</code> <pre><code>def add_line_3d(\n    self,\n    p1: Union[SlvsPoint3D, int],\n    p2: Union[SlvsPoint3D, int],\n    fixed: bool = False,\n    construction: bool = False,\n    index_reference: bool = False,\n) -&gt; SlvsLine3D:\n    \"\"\"Add a line in 3d space.\n\n    Arguments:\n        p1: Line's startpoint.\n        p2: Line's endpoint.\n\n    Returns:\n        SlvsLine3D: The created line.\n    \"\"\"\n    line = self.lines3D.add()\n    line[\"p1_i\"] = p1 if isinstance(p1, int) else p1.slvs_index\n    line[\"p2_i\"] = p2 if isinstance(p2, int) else p2.slvs_index\n\n    return self._init_entity(line, fixed, construction, index_reference)\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsEntities.add_normal_2d","title":"<code>add_normal_2d(sketch, fixed=False, construction=False, index_reference=False)</code>","text":"<p>Add a normal in 2d space.</p> <p>Parameters:</p> Name Type Description Default <code>sketch</code> <code>SlvsSketch</code> <p>The sketch this normal belongs to.</p> required <p>Returns:</p> Name Type Description <code>SlvsNormal2D</code> <code>SlvsNormal2D</code> <p>The created normal.</p> Source code in <code>model/group_entities.py</code> <pre><code>def add_normal_2d(\n    self,\n    sketch: SlvsSketch,\n    fixed: bool = False,\n    construction: bool = False,\n    index_reference: bool = False,\n) -&gt; SlvsNormal2D:\n    \"\"\"Add a normal in 2d space.\n\n    Arguments:\n        sketch: The sketch this normal belongs to.\n\n    Returns:\n        SlvsNormal2D: The created normal.\n    \"\"\"\n    nm = self.normals2D.add()\n    nm[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n\n    return self._init_entity(nm, fixed, construction, index_reference)\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsEntities.add_normal_3d","title":"<code>add_normal_3d(quat, fixed=False, construction=False, index_reference=False)</code>","text":"<p>Add a normal in 3d space.</p> <p>Parameters:</p> Name Type Description Default <code>quat</code> <code>Tuple[float, float, float, float]</code> <p>Quaternion which describes the orientation.</p> required <p>Returns:</p> Name Type Description <code>SlvsNormal3D</code> <code>SlvsNormal3D</code> <p>The created normal.</p> Source code in <code>model/group_entities.py</code> <pre><code>def add_normal_3d(\n    self,\n    quat: Tuple[float, float, float, float],\n    fixed: bool = False,\n    construction: bool = False,\n    index_reference: bool = False,\n) -&gt; SlvsNormal3D:\n    \"\"\"Add a normal in 3d space.\n\n    Arguments:\n        quat: Quaternion which describes the orientation.\n\n    Returns:\n        SlvsNormal3D: The created normal.\n    \"\"\"\n    nm = self.normals3D.add()\n    nm[\"orientation\"] = Quaternion(quat)\n\n    return self._init_entity(nm, fixed, construction, index_reference)\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsEntities.add_point_2d","title":"<code>add_point_2d(co, sketch, fixed=False, construction=False, index_reference=False)</code>","text":"<p>Add a point in 2d space.</p> <p>Parameters:</p> Name Type Description Default <code>co</code> <code>Tuple[float, float]</code> <p>Coordinates of the point on the workplane.</p> required <code>sketch</code> <code>SlvsSketch</code> <p>The sketch this point belongs to.</p> required <p>Returns:</p> Name Type Description <code>SlvsPoint2D</code> <code>SlvsPoint2D</code> <p>The created point.</p> Source code in <code>model/group_entities.py</code> <pre><code>def add_point_2d(\n    self,\n    co: Tuple[float, float],\n    sketch: SlvsSketch,\n    fixed: bool = False,\n    construction: bool = False,\n    index_reference: bool = False,\n) -&gt; SlvsPoint2D:\n    \"\"\"Add a point in 2d space.\n\n    Arguments:\n        co: Coordinates of the point on the workplane.\n        sketch: The sketch this point belongs to.\n\n    Returns:\n        SlvsPoint2D: The created point.\n    \"\"\"\n    p = self.points2D.add()\n    p[\"co\"] = Vector(co)\n    p[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n\n    return self._init_entity(p, fixed, construction, index_reference)\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsEntities.add_point_3d","title":"<code>add_point_3d(co, fixed=False, construction=False, index_reference=False)</code>","text":"<p>Add a point in 3d space.</p> <p>Parameters:</p> Name Type Description Default <code>co</code> <code>Union[Tuple[float, float, float], Vector]</code> <p>Location of the point in 3d space.</p> required <p>Returns:</p> Name Type Description <code>SlvsPoint3D</code> <code>Union[SlvsPoint3D, int]</code> <p>The created point.</p> Source code in <code>model/group_entities.py</code> <pre><code>def add_point_3d(\n    self,\n    co: Union[Tuple[float, float, float], Vector],\n    fixed: bool = False,\n    construction: bool = False,\n    index_reference: bool = False,\n) -&gt; Union[SlvsPoint3D, int]:\n    \"\"\"Add a point in 3d space.\n\n    Arguments:\n        co: Location of the point in 3d space.\n\n    Returns:\n        SlvsPoint3D: The created point.\n    \"\"\"\n    if not hasattr(co, \"__len__\") or len(co) != 3:\n        raise TypeError(\"Argument co must be of length 3\")\n\n    p = self.points3D.add()\n    p[\"location\"] = Vector(co)\n    return self._init_entity(p, fixed, construction, index_reference)\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsEntities.add_sketch","title":"<code>add_sketch(wp, fixed=False, construction=False, index_reference=False)</code>","text":"<p>Add a Sketch.</p> <p>Parameters:</p> Name Type Description Default <code>wp</code> <code>SlvsWorkplane</code> <p>Sketch's workplane.</p> required <p>Returns:</p> Name Type Description <code>SlvsSketch</code> <code>SlvsSketch</code> <p>The created sketch.</p> Source code in <code>model/group_entities.py</code> <pre><code>def add_sketch(\n    self,\n    wp: SlvsWorkplane,\n    fixed: bool = False,\n    construction: bool = False,\n    index_reference: bool = False,\n) -&gt; SlvsSketch:\n    \"\"\"Add a Sketch.\n\n    Arguments:\n        wp: Sketch's workplane.\n\n    Returns:\n        SlvsSketch: The created sketch.\n    \"\"\"\n    sketch = self.sketches.add()\n    sketch[\"wp_i\"] = wp if isinstance(wp, int) else wp.slvs_index\n\n    retval = self._init_entity(sketch, fixed, construction, index_reference)\n    index = retval if index_reference else retval.slvs_index\n    _, i = self._breakdown_index(index)\n    sketch.name = \"Sketch\"\n    return retval\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsEntities.add_workplane","title":"<code>add_workplane(p1, nm, fixed=False, construction=False, index_reference=False)</code>","text":"<p>Add a workplane.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>SlvsPoint3D</code> <p>Workplane's originpoint.</p> required <code>nm</code> <code>SlvsGenericEntity</code> <p>Workplane's normal.</p> required <p>Returns:</p> Name Type Description <code>SlvsWorkplane</code> <code>SlvsWorkplane</code> <p>The created workplane.</p> Source code in <code>model/group_entities.py</code> <pre><code>def add_workplane(\n    self,\n    p1: SlvsPoint3D,\n    nm: SlvsGenericEntity,\n    fixed: bool = False,\n    construction: bool = False,\n    index_reference: bool = False,\n) -&gt; SlvsWorkplane:\n    \"\"\"Add a workplane.\n\n    Arguments:\n        p1: Workplane's originpoint.\n        nm: Workplane's normal.\n\n    Returns:\n        SlvsWorkplane: The created workplane.\n    \"\"\"\n    wp = self.workplanes.add()\n    wp[\"p1_i\"] = p1 if isinstance(p1, int) else p1.slvs_index\n    wp[\"nm_i\"] = nm if isinstance(nm, int) else nm.slvs_index\n\n    return self._init_entity(wp, fixed, construction, index_reference)\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsEntities.get","title":"<code>get(index)</code>","text":"<p>Get entity by index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The global index of the entity.</p> required <p>Returns:</p> Name Type Description <code>SlvsGenericEntity</code> <code>SlvsGenericEntity</code> <p>Entity with the given global index or None if not found.</p> Source code in <code>model/group_entities.py</code> <pre><code>def get(self, index: int) -&gt; SlvsGenericEntity:\n    \"\"\"Get entity by index\n\n    Arguments:\n        index: The global index of the entity.\n\n    Returns:\n        SlvsGenericEntity: Entity with the given global index or None if not found.\n    \"\"\"\n    if index == -1:\n        return None\n    sub_list, i = self._get_list_and_index(index)\n    if not sub_list or i &gt;= len(sub_list):\n        return None\n    return sub_list[i]\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsEntities.remove","title":"<code>remove(index)</code>","text":"<p>Remove entity by index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The global index of the entity.</p> required Source code in <code>model/group_entities.py</code> <pre><code>def remove(self, index: int):\n    \"\"\"Remove entity by index\n\n    Arguments:\n        index: The global index of the entity.\n    \"\"\"\n    assert isinstance(index, int)\n\n    if self.get(index).origin:\n        return\n\n    entity_list, i = self._get_list_and_index(index)\n    entity_list.remove(i)\n\n    # Put last item to removed index and update all pointers to it\n    last_index = len(entity_list) - 1\n\n    if last_index &lt; 0:\n        return\n    if i &gt; last_index:\n        return\n\n    if not i == last_index:  # second last item was deleted\n        entity_list.move(last_index, i)\n\n    new_item = entity_list[i]\n    update_pointers(bpy.context.scene, new_item.slvs_index, index)\n    new_item.slvs_index = index\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsConstraints.add_angle","title":"<code>add_angle(entity1, entity2, sketch=None, init=False, **settings)</code>","text":"<p>Add an angle constraint.</p> <p>Parameters:</p> Name Type Description Default <code>entity1</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>entity2</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>sketch</code> <code>SlvsSketch</code> <p>The sketch this constraint belongs to.</p> <code>None</code> <code>init</code> <code>bool</code> <p>Initialize the constraint based on the given entities.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SlvsAngle</code> <code>SlvsAngle</code> <p>The created constraint.</p> Source code in <code>model/group_constraints.py</code> <pre><code>def add_angle(\n    self,\n    entity1: SlvsGenericEntity,\n    entity2: SlvsGenericEntity,\n    sketch: SlvsSketch = None,\n    init: bool = False,\n    **settings,\n) -&gt; SlvsAngle:\n    \"\"\"Add an angle constraint.\n\n    Arguments:\n        entity1: -\n        entity2: -\n        sketch: The sketch this constraint belongs to.\n        init: Initialize the constraint based on the given entities.\n\n    Returns:\n        SlvsAngle: The created constraint.\n    \"\"\"\n    c = self.angle.add()\n    c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n    c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n    if sketch is not None:\n        c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n    if init:\n        c.assign_init_props(**settings)\n    else:\n        c.assign_settings(**settings)\n    return c\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsConstraints.add_coincident","title":"<code>add_coincident(entity1, entity2, sketch=None)</code>","text":"<p>Add a coincident constraint.</p> <p>Parameters:</p> Name Type Description Default <code>entity1</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>entity2</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>sketch</code> <code>SlvsSketch</code> <p>The sketch this constraint belongs to.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SlvsCoincident</code> <code>SlvsCoincident</code> <p>The created constraint.</p> Source code in <code>model/group_constraints.py</code> <pre><code>def add_coincident(\n    self,\n    entity1: SlvsGenericEntity,\n    entity2: SlvsGenericEntity,\n    sketch: SlvsSketch = None,\n) -&gt; SlvsCoincident:\n    \"\"\"Add a coincident constraint.\n\n    Arguments:\n        entity1: -\n        entity2: -\n        sketch: The sketch this constraint belongs to.\n\n    Returns:\n        SlvsCoincident: The created constraint.\n    \"\"\"\n\n    if all([e.is_point() for e in (entity1, entity2)]):\n        # TODO: Implicitly merge points\n        return\n\n    c = self.coincident.add()\n    c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n    c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n    if sketch:\n        c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n    return c\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsConstraints.add_diameter","title":"<code>add_diameter(entity1, sketch=None, init=False, **settings)</code>","text":"<p>Add a diameter constraint.</p> <p>Parameters:</p> Name Type Description Default <code>entity1</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>sketch</code> <code>SlvsSketch</code> <p>The sketch this constraint belongs to.</p> <code>None</code> <code>init</code> <code>bool</code> <p>Initialize the constraint based on the given entities.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SlvsDiameter</code> <code>SlvsDiameter</code> <p>The created constraint.</p> Source code in <code>model/group_constraints.py</code> <pre><code>def add_diameter(\n    self,\n    entity1: SlvsGenericEntity,\n    sketch: SlvsSketch = None,\n    init: bool = False,\n    **settings,\n) -&gt; SlvsDiameter:\n    \"\"\"Add a diameter constraint.\n\n    Arguments:\n        entity1: -\n        sketch: The sketch this constraint belongs to.\n        init: Initialize the constraint based on the given entities.\n\n    Returns:\n        SlvsDiameter: The created constraint.\n    \"\"\"\n    c = self.diameter.add()\n    c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n    if sketch:\n        c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n    if init:\n        c.assign_init_props(**settings)\n    else:\n        c.assign_settings(**settings)\n    return c\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsConstraints.add_distance","title":"<code>add_distance(entity1, entity2, sketch=None, init=False, **settings)</code>","text":"<p>Add a distance constraint.</p> <p>Parameters:</p> Name Type Description Default <code>entity1</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>entity2</code> <code>Union[None, SlvsGenericEntity]</code> <p>-</p> required <code>sketch</code> <code>Union[SlvsSketch, None]</code> <p>The sketch this constraint belongs to.</p> <code>None</code> <code>init</code> <code>bool</code> <p>Initialize the constraint based on the given entities.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SlvsDistance</code> <code>SlvsDistance</code> <p>The created constraint.</p> Source code in <code>model/group_constraints.py</code> <pre><code>def add_distance(\n    self,\n    entity1: SlvsGenericEntity,\n    entity2: Union[None, SlvsGenericEntity],\n    sketch: Union[SlvsSketch, None] = None,\n    init: bool = False,\n    **settings,\n) -&gt; SlvsDistance:\n    \"\"\"Add a distance constraint.\n\n    Arguments:\n        entity1: -\n        entity2: -\n        sketch: The sketch this constraint belongs to.\n        init: Initialize the constraint based on the given entities.\n\n    Returns:\n        SlvsDistance: The created constraint.\n    \"\"\"\n    c = self.distance.add()\n    c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n\n    if entity2 is not None:\n        c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n    if sketch is not None:\n        c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n    if init:\n        c.assign_init_props(**settings)\n    else:\n        c.assign_settings(**settings)\n    return c\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsConstraints.add_equal","title":"<code>add_equal(entity1, entity2, sketch=None)</code>","text":"<p>Add an equal constraint.</p> <p>Parameters:</p> Name Type Description Default <code>entity1</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>entity2</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>sketch</code> <code>Union[SlvsSketch, None]</code> <p>The sketch this constraint belongs to.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SlvsEqual</code> <code>SlvsEqual</code> <p>The created constraint.</p> Source code in <code>model/group_constraints.py</code> <pre><code>def add_equal(\n    self,\n    entity1: SlvsGenericEntity,\n    entity2: SlvsGenericEntity,\n    sketch: Union[SlvsSketch, None] = None,\n) -&gt; SlvsEqual:\n    \"\"\"Add an equal constraint.\n\n    Arguments:\n        entity1: -\n        entity2: -\n        sketch: The sketch this constraint belongs to.\n\n    Returns:\n        SlvsEqual: The created constraint.\n    \"\"\"\n    c = self.equal.add()\n    c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n    c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n    if sketch is not None:\n        c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n    return c\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsConstraints.add_horizontal","title":"<code>add_horizontal(entity1, entity2=None, sketch=None)</code>","text":"<p>Add a horizontal constraint.</p> <p>Parameters:</p> Name Type Description Default <code>entity1</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>sketch</code> <code>Union[SlvsSketch, None]</code> <p>The sketch this constraint belongs to.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SlvsHorizontal</code> <code>SlvsHorizontal</code> <p>The created constraint.</p> Source code in <code>model/group_constraints.py</code> <pre><code>def add_horizontal(\n    self,\n    entity1: SlvsGenericEntity,\n    entity2: SlvsGenericEntity = None,\n    sketch: Union[SlvsSketch, None] = None,\n) -&gt; SlvsHorizontal:\n    \"\"\"Add a horizontal constraint.\n\n    Arguments:\n        entity1: -\n        sketch: The sketch this constraint belongs to.\n\n    Returns:\n        SlvsHorizontal: The created constraint.\n    \"\"\"\n    c = self.horizontal.add()\n    c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n    if entity2 is not None:\n        c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n    if sketch is not None:\n        c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n    return c\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsConstraints.add_midpoint","title":"<code>add_midpoint(entity1, entity2, sketch=None)</code>","text":"<p>Add a midpoint constraint.</p> <p>Parameters:</p> Name Type Description Default <code>entity1</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>entity2</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>sketch</code> <code>Union[SlvsSketch, None]</code> <p>The sketch this constraint belongs to.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SlvsMidpoint</code> <code>SlvsMidpoint</code> <p>The created constraint.</p> Source code in <code>model/group_constraints.py</code> <pre><code>def add_midpoint(\n    self,\n    entity1: SlvsGenericEntity,\n    entity2: SlvsGenericEntity,\n    sketch: Union[SlvsSketch, None] = None,\n) -&gt; SlvsMidpoint:\n    \"\"\"Add a midpoint constraint.\n\n    Arguments:\n        entity1: -\n        entity2: -\n        sketch: The sketch this constraint belongs to.\n\n    Returns:\n        SlvsMidpoint: The created constraint.\n    \"\"\"\n    c = self.midpoint.add()\n    c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n    c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n    if sketch is not None:\n        c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n    return c\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsConstraints.add_parallel","title":"<code>add_parallel(entity1, entity2, sketch=None)</code>","text":"<p>Add a parallel constraint.</p> <p>Parameters:</p> Name Type Description Default <code>entity1</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>entity2</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>sketch</code> <code>Union[SlvsSketch, None]</code> <p>The sketch this constraint belongs to.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SlvsParallel</code> <code>SlvsParallel</code> <p>The created constraint.</p> Source code in <code>model/group_constraints.py</code> <pre><code>def add_parallel(\n    self,\n    entity1: SlvsGenericEntity,\n    entity2: SlvsGenericEntity,\n    sketch: Union[SlvsSketch, None] = None,\n) -&gt; SlvsParallel:\n    \"\"\"Add a parallel constraint.\n\n    Arguments:\n        entity1: -\n        entity2: -\n        sketch: The sketch this constraint belongs to.\n\n    Returns:\n        SlvsParallel: The created constraint.\n    \"\"\"\n    c = self.parallel.add()\n    c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n    c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n    if sketch is not None:\n        c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n    return c\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsConstraints.add_perpendicular","title":"<code>add_perpendicular(entity1, entity2, sketch=None)</code>","text":"<p>Add a perpendicular constraint.</p> <p>Parameters:</p> Name Type Description Default <code>entity1</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>entity2</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>sketch</code> <code>Union[SlvsSketch, None]</code> <p>The sketch this constraint belongs to.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SlvsPerpendicular</code> <code>SlvsPerpendicular</code> <p>The created constraint.</p> Source code in <code>model/group_constraints.py</code> <pre><code>def add_perpendicular(\n    self,\n    entity1: SlvsGenericEntity,\n    entity2: SlvsGenericEntity,\n    sketch: Union[SlvsSketch, None] = None,\n) -&gt; SlvsPerpendicular:\n    \"\"\"Add a perpendicular constraint.\n\n    Arguments:\n        entity1: -\n        entity2: -\n        sketch: The sketch this constraint belongs to.\n\n    Returns:\n        SlvsPerpendicular: The created constraint.\n    \"\"\"\n    c = self.perpendicular.add()\n    c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n    c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n    if sketch is not None:\n        c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n    return c\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsConstraints.add_ratio","title":"<code>add_ratio(entity1, entity2, sketch=None, init=False, **settings)</code>","text":"<p>Add a ratio constraint.</p> <p>Parameters:</p> Name Type Description Default <code>entity1</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>entity2</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>sketch</code> <code>Union[SlvsSketch, None]</code> <p>The sketch this constraint belongs to.</p> <code>None</code> <code>init</code> <code>bool</code> <p>Initialize the constraint based on the given entities.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SlvsRatio</code> <code>SlvsRatio</code> <p>The created constraint.</p> Source code in <code>model/group_constraints.py</code> <pre><code>def add_ratio(\n    self,\n    entity1: SlvsGenericEntity,\n    entity2: SlvsGenericEntity,\n    sketch: Union[SlvsSketch, None] = None,\n    init: bool = False,\n    **settings,\n) -&gt; SlvsRatio:\n    \"\"\"Add a ratio constraint.\n\n    Arguments:\n        entity1: -\n        entity2: -\n        sketch: The sketch this constraint belongs to.\n        init: Initialize the constraint based on the given entities.\n\n    Returns:\n        SlvsRatio: The created constraint.\n    \"\"\"\n    c = self.ratio.add()\n    c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n    c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n    if sketch is not None:\n        c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n    if init:\n        c.assign_init_props(**settings)\n    else:\n        c.assign_settings(**settings)\n    return c\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsConstraints.add_tangent","title":"<code>add_tangent(entity1, entity2, sketch=None)</code>","text":"<p>Add a tangent constraint.</p> <p>Parameters:</p> Name Type Description Default <code>entity1</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>entity2</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>sketch</code> <code>Union[SlvsSketch, None]</code> <p>The sketch this constraint belongs to.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SlvsTangent</code> <code>SlvsTangent</code> <p>The created constraint.</p> Source code in <code>model/group_constraints.py</code> <pre><code>def add_tangent(\n    self,\n    entity1: SlvsGenericEntity,\n    entity2: SlvsGenericEntity,\n    sketch: Union[SlvsSketch, None] = None,\n) -&gt; SlvsTangent:\n    \"\"\"Add a tangent constraint.\n\n    Arguments:\n        entity1: -\n        entity2: -\n        sketch: The sketch this constraint belongs to.\n\n    Returns:\n        SlvsTangent: The created constraint.\n    \"\"\"\n    c = self.tangent.add()\n    c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n    c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n    if sketch is not None:\n        c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n    return c\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsConstraints.add_vertical","title":"<code>add_vertical(entity1, entity2=None, sketch=None)</code>","text":"<p>Add a vertical constraint.</p> <p>Parameters:</p> Name Type Description Default <code>entity1</code> <code>SlvsGenericEntity</code> <p>-</p> required <code>sketch</code> <code>Union[SlvsSketch, None]</code> <p>The sketch this constraint belongs to.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SlvsVertical</code> <code>SlvsVertical</code> <p>The created constraint.</p> Source code in <code>model/group_constraints.py</code> <pre><code>def add_vertical(\n    self,\n    entity1: SlvsGenericEntity,\n    entity2: SlvsGenericEntity = None,\n    sketch: Union[SlvsSketch, None] = None,\n) -&gt; SlvsVertical:\n    \"\"\"Add a vertical constraint.\n\n    Arguments:\n        entity1: -\n        sketch: The sketch this constraint belongs to.\n\n    Returns:\n        SlvsVertical: The created constraint.\n    \"\"\"\n    c = self.vertical.add()\n    c[\"entity1_i\"] = entity1 if isinstance(entity1, int) else entity1.slvs_index\n    if entity2 is not None:\n        c[\"entity2_i\"] = entity2 if isinstance(entity2, int) else entity2.slvs_index\n    if sketch is not None:\n        c[\"sketch_i\"] = sketch if isinstance(sketch, int) else sketch.slvs_index\n    return c\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsConstraints.get_from_type_index","title":"<code>get_from_type_index(type, index)</code>","text":"<p>Get constraint by type and local index.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>Constraint's type.</p> required <code>index</code> <code>int</code> <p>Constraint's local index.</p> required <p>Returns:</p> Name Type Description <code>GenericConstraint</code> <code>GenericConstraint</code> <p>Constraint with the given type and index or None if not found.</p> Source code in <code>model/group_constraints.py</code> <pre><code>def get_from_type_index(self, type: str, index: int) -&gt; GenericConstraint:\n    \"\"\"Get constraint by type and local index.\n\n    Arguments:\n        type: Constraint's type.\n        index: Constraint's local index.\n\n    Returns:\n        GenericConstraint: Constraint with the given type and index or None if not found.\n    \"\"\"\n    list = getattr(self, type.lower())\n    if not list or index &gt;= len(list):\n        return None\n    return list[index]\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsConstraints.get_index","title":"<code>get_index(constr)</code>","text":"<p>Get the index of a constraint in its collection.</p> <p>Parameters:</p> Name Type Description Default <code>constr</code> <code>GenericConstraint</code> <p>Constraint to get the index for.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the constraint or -1 if not found.</p> Source code in <code>model/group_constraints.py</code> <pre><code>def get_index(self, constr: GenericConstraint) -&gt; int:\n    \"\"\"Get the index of a constraint in its collection.\n\n    Arguments:\n        constr: Constraint to get the index for.\n\n    Returns:\n        int: Index of the constraint or -1 if not found.\n    \"\"\"\n    list = getattr(self, constr.type.lower())\n    for i, item in enumerate(list):\n        if item == constr:\n            return i\n    return -1\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsConstraints.new_from_type","title":"<code>new_from_type(type)</code>","text":"<p>Create a constraint by type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>Type of the constraint to be created.</p> required Source code in <code>model/group_constraints.py</code> <pre><code>def new_from_type(self, type: str) -&gt; GenericConstraint:\n    \"\"\"Create a constraint by type.\n\n    Arguments:\n        type: Type of the constraint to be created.\n    \"\"\"\n    name = type.lower()\n    constraint_list = getattr(self, name)\n    return constraint_list.add()\n</code></pre>"},{"location":"reference/#CAD_Sketcher.model.types.SlvsConstraints.remove","title":"<code>remove(constr)</code>","text":"<p>Remove a constraint.</p> <p>Parameters:</p> Name Type Description Default <code>constr</code> <code>GenericConstraint</code> <p>Constraint to be removed.</p> required Source code in <code>model/group_constraints.py</code> <pre><code>def remove(self, constr: GenericConstraint):\n    \"\"\"Remove a constraint.\n\n    Arguments:\n        constr: Constraint to be removed.\n    \"\"\"\n    i = self.get_index(constr)\n    self.get_list(constr.type).remove(i)\n</code></pre>"},{"location":"solver/","title":"Solver","text":"<p>The extension utilizes the solver from solvespace which takes a set of entities with an initial position and a set of constraints which describe geometric relationships between entities. When the solver runs it will try to adjust entity locations to satisfy the constraints.</p>"},{"location":"solver/#failure","title":"Failure","text":"<p>It's common that the solver fails to find a solution to satisfy all constraints. There are multiple reasons why the solver might fail. Whenever this happens the active sketch will be marked in the sidebar. It will have one of the following states:</p> <ul> <li>Okay</li> <li>Inconsistent</li> <li>Didnt Converge</li> <li>Too Many Unknowns</li> <li>Unknown Failure</li> </ul>"},{"location":"tools/","title":"Tools","text":"<p>Tools in CAD Sketcher are either exposed as a workspacetool or as an operator. Note however that either of those use the same interaction system.</p>"},{"location":"tools/#generic-tools","title":"Generic Tools","text":"<p>               Bases: <code>Operator</code>, <code>Operator3d</code></p> <p>Add a sketch</p> Source code in <code>operators/add_sketch.py</code> <pre><code>class View3D_OT_slvs_add_sketch(Operator, Operator3d):\n    \"\"\"Add a sketch\"\"\"\n\n    bl_idname = Operators.AddSketch\n    bl_label = \"Add Sketch\"\n    bl_options = {\"UNDO\"}\n\n    sketch_state1_doc = [\"Workplane\", \"Pick a workplane as base for the sketch.\"]\n\n    states = (\n        state_from_args(\n            sketch_state1_doc[0],\n            description=sketch_state1_doc[1],\n            pointer=\"wp\",\n            types=(SlvsWorkplane,),\n            property=None,\n            use_create=False,\n        ),\n    )\n\n    def prepare_origin_elements(self, context):\n        context.scene.sketcher.entities.ensure_origin_elements(context)\n        return True\n\n    def init(self, context: Context, event: Event):\n        switch_sketch_mode(self, context, to_sketch_mode=True)\n        self.prepare_origin_elements(context)\n        bpy.ops.ed.undo_push(message=\"Ensure Origin Elements\")\n        context.scene.sketcher.show_origin = True\n        return True\n\n    def main(self, context: Context):\n        sse = context.scene.sketcher.entities\n        sketch = sse.add_sketch(self.wp)\n\n        # Add point at origin\n        # NOTE: Maybe this could create a reference entity of the main origin?\n        p = sse.add_point_2d((0.0, 0.0), sketch)\n        p.fixed = True\n\n        activate_sketch(context, sketch.slvs_index, self)\n        self.target = sketch\n        return True\n\n    def fini(self, context: Context, succeed: bool):\n        context.scene.sketcher.show_origin = False\n        if hasattr(self, \"target\"):\n            logger.debug(\"Add: {}\".format(self.target))\n\n        if succeed:\n            self.wp.visible = False\n        else:\n            switch_sketch_mode(self, context, to_sketch_mode=False)\n</code></pre> <p>               Bases: <code>Operator</code>, <code>HighlightElement</code></p> <p>Delete Entity by index or based on the selection if index isn't provided</p> Source code in <code>operators/delete_entity.py</code> <pre><code>class View3D_OT_slvs_delete_entity(Operator, HighlightElement):\n    \"\"\"Delete Entity by index or based on the selection if index isn't provided\"\"\"\n\n    bl_idname = Operators.DeleteEntity\n    bl_label = \"Delete Entity\"\n    bl_description = (\n        \"Delete Entity by index or based on the selection if index isn't provided\"\n    )\n    bl_options = {\"UNDO\"}\n\n    index: IntProperty(default=-1)\n    do_report: BoolProperty(\n        name=\"Report\", description=\"Report entities that prevent deletion\", default=True\n    )\n\n    @staticmethod\n    def main(context: Context, index: int, operator: Operator):\n        entities = context.scene.sketcher.entities\n        entity = entities.get(index)\n\n        if not entity:\n            return {\"CANCELLED\"}\n\n        if isinstance(entity, SlvsSketch):\n            if context.scene.sketcher.active_sketch_i != -1:\n                activate_sketch(context, -1, operator)\n            entity.remove_objects()\n\n            deps = get_sketch_deps_indicies(entity, context)\n\n            for i in reversed(deps):\n                operator.delete(entities.get(i), context)\n\n        elif is_entity_dependency(entity, context):\n            if operator.do_report:\n                deps = list(get_entity_deps(entity, context))\n                msg_deps = \"\\n\".join([f\" - {d}\" for d in deps])\n                message = f\"Unable to delete {entity.name}, other entities depend on it:\\n{msg_deps}\"\n                show_ui_message_popup(message=message, icon=\"ERROR\")\n\n                operator.report(\n                    {\"WARNING\"},\n                    \"Cannot delete {}, other entities depend on it.\".format(\n                        entity.name\n                    ),\n                )\n            return {\"CANCELLED\"}\n\n        operator.delete(entity, context)\n\n    @staticmethod\n    def delete(entity, context: Context):\n        entity.selected = False\n\n        # Delete constraints that depend on entity\n        constraints = context.scene.sketcher.constraints\n\n        for data_coll, indices in get_constraint_local_indices(entity, context):\n            if not indices:\n                continue\n            for i in reversed(indices):\n                logger.debug(\"Delete: {}, {}\".format(data_coll, i))\n                data_coll.remove(i)\n\n        logger.debug(\"Delete: {}\".format(entity))\n        entities = context.scene.sketcher.entities\n        entities.remove(entity.slvs_index)\n\n    def execute(self, context: Context):\n        index = self.index\n        selected = context.scene.sketcher.entities.selected_active\n\n        if index != -1:\n            # Entity is specified via property\n            self.main(context, index, self)\n        elif len(selected) == 1:\n            # Treat single selection same as specified entity\n            self.main(context, selected[0].slvs_index, self)\n        else:\n            # Batch deletion\n            indices = []\n            for e in selected:\n                indices.append(e.slvs_index)\n\n            indices.sort(reverse=True)\n            for i in indices:\n                e = context.scene.sketcher.entities.get(i)\n\n                # NOTE: this might be slow when a lot of entities are selected, improve!\n                if is_entity_dependency(e, context):\n                    continue\n                self.delete(e, context)\n\n        solve_system(context, context.scene.sketcher.active_sketch)\n        refresh(context)\n        return {\"FINISHED\"}\n</code></pre> <p>               Bases: <code>Operator</code>, <code>HighlightElement</code></p> <p>Delete constraint by type and index</p> Source code in <code>operators/delete_constraint.py</code> <pre><code>class View3D_OT_slvs_delete_constraint(Operator, HighlightElement):\n    \"\"\"Delete constraint by type and index\"\"\"\n\n    bl_idname = Operators.DeleteConstraint\n    bl_label = \"Delete Constraint\"\n    bl_description = \"Delete Constraint\"\n    bl_options = {\"UNDO\"}\n\n    type: StringProperty(name=\"Type\")\n    index: IntProperty(default=-1)\n\n    @classmethod\n    def description(cls, context, properties):\n        cls.handle_highlight_hover(context, properties)\n        if properties.type:\n            return \"Delete: \" + properties.type.capitalize()\n        return \"\"\n\n    def execute(self, context: Context):\n        constraints = context.scene.sketcher.constraints\n\n        # NOTE: It's not really necessary to first get the\n        # constraint from its index before deleting\n\n        constr = constraints.get_from_type_index(self.type, self.index)\n        logger.debug(\"Delete: {}\".format(constr))\n\n        constraints.remove(constr)\n\n        sketch = context.scene.sketcher.active_sketch\n        solve_system(context, sketch=sketch)\n        refresh(context)\n        return {\"FINISHED\"}\n</code></pre>"},{"location":"tools/#workspacetools","title":"Workspacetools","text":"<p>Workspacetools are used to interactively create entities. You can access them from the viewport's \"T\"-panel. Check the tools section to get familiar with the behavior of CAD Sketcher tools.</p> <p>INFO: Interaction with extension geometry is only possible when one of the extension tools is active.</p>"},{"location":"tools/#workspacetool-access-keymap","title":"Workspacetool Access Keymap","text":"<p>Whenever one of the extension's tools is active the tool access keymap allows to quickly switch between the different tools.</p> Key Modifier Action ESC - Activate Tool: Select P - Invoke Tool: Add Point 2D L - Invoke Tool: Add Line 2D C - Invoke Tool: Add Circle A - Invoke Tool: Add Arc R - Invoke Tool: Add Rectangle S - Invoke Tool: Add Sketch Y - Invoke Tool: Trim <p>Dimensional Constraints:</p> Key Modifier Action D Alt Distance V Alt Vertical Distance H Alt Horizontal Distance A Alt Angle O Alt Diameter R Alt Radius <p>Geometric Constraints:</p> Key Modifier Action C Shift Coincident V Shift Vertical H Shift Horizontal E Shift Equal P Shift Parallel N Shift Perpendicular T Shift Tangent M Shift Midpoint R Shift Ratio"},{"location":"tools/#basic-tool-keymap","title":"Basic Tool Keymap","text":"<p>The basic tool interaction is consistent between tools.</p> Key Modifier Action Tab - Jump to next tool state or property substate when in numerical edit 0-9 / (-) - Activate numeric edit Enter / Lmb - Verify the operation Esc / Rmb - Cancel the operation <p>While numeric edit is active</p> Key Modifier Action Tab - Jump to next tool property substate 0-9 - Activate numeric edit Minus(-) - Toggle between positive and negative values"},{"location":"tools/#selection-tools","title":"Selection tools","text":"<p>               Bases: <code>Operator</code>, <code>HighlightElement</code></p> <p>Select an entity</p> <p>Either the entity specified by the index property or the hovered index if the index property is not set</p> Source code in <code>operators/select.py</code> <pre><code>class View3D_OT_slvs_select(Operator, HighlightElement):\n    \"\"\"\n    Select an entity\n\n    Either the entity specified by the index property or the hovered index\n    if the index property is not set\n\n    \"\"\"\n\n    bl_idname = Operators.Select\n    bl_label = \"Select Sketch Entities\"\n\n    index: IntProperty(name=\"Index\", default=-1)\n    mode: mode_property\n\n    def execute(self, context: Context):\n        index = (\n            self.index\n            if self.properties.is_property_set(\"index\")\n            else global_data.hover\n        )\n        hit = index != -1\n        mode = self.mode\n\n        if mode == \"SET\" or not hit:\n            deselect_all(context)\n\n        if hit:\n            entity = context.scene.sketcher.entities.get(index)\n\n            value = True\n            if mode == \"SUBTRACT\":\n                value = False\n            if mode == \"TOGGLE\":\n                value = not entity.selected\n\n            entity.selected = value\n\n        context.area.tag_redraw()\n        return {\"FINISHED\"}\n</code></pre> <p>               Bases: <code>Operator</code></p> <p>Select / Deselect all entities</p> Source code in <code>operators/select.py</code> <pre><code>class View3D_OT_slvs_select_all(Operator):\n    \"\"\"Select / Deselect all entities\"\"\"\n\n    bl_idname = Operators.SelectAll\n    bl_label = \"Select / Deselect Entities\"\n\n    deselect: BoolProperty(name=\"Deselect\")\n\n    def execute(self, context: Context):\n        if self.deselect:\n            deselect_all(context)\n        else:\n            select_all(context)\n        context.area.tag_redraw()\n        return {\"FINISHED\"}\n</code></pre> <p>               Bases: <code>Operator</code></p> <p>Invert entities selection</p> Source code in <code>operators/select.py</code> <pre><code>class View3D_OT_slvs_select_invert(Operator):\n    \"\"\"Invert entities selection\"\"\"\n\n    bl_idname = Operators.SelectInvert\n    bl_label = \"Invert entities selection\"\n\n    def execute(self, context: Context):\n        select_invert(context)\n        context.area.tag_redraw()\n        return {\"FINISHED\"}\n</code></pre> <p>               Bases: <code>Operator</code></p> <p>Select neighbour entities</p> Source code in <code>operators/select.py</code> <pre><code>class View3D_OT_slvs_select_extend(Operator):\n    \"\"\"Select neighbour entities\"\"\"\n\n    bl_idname = Operators.SelectExtend\n    bl_label = \"Select neighbour entities\"\n\n    def execute(self, context: Context):\n        select_extend(context)\n        context.area.tag_redraw()\n        return {\"FINISHED\"}\n</code></pre> <p>               Bases: <code>Operator</code></p> <p>Select neighbour entities</p> Source code in <code>operators/select.py</code> <pre><code>class View3D_OT_slvs_select_extend_all(Operator):\n    \"\"\"Select neighbour entities\"\"\"\n\n    bl_idname = Operators.SelectExtendAll\n    bl_label = \"Select neighbour entities\"\n\n    def execute(self, context: Context):\n        while select_extend(context):\n            pass\n        context.area.tag_redraw()\n        return {\"FINISHED\"}\n</code></pre> <p>Keymap:</p> Key Modifier Action LMB - Toggle Select ESC - Deselect All I Ctrl Inverse selection E Ctrl Extend selection in chain E Ctrl+Shift Select full chain <p>INFO: LMB in empty space will also deselect all.</p> <p>INFO: Chain selection works with coincident constraints too</p> <p>               Bases: <code>Operator</code>, <code>Operator3d</code></p> <p>Add a point in 3d space</p> Source code in <code>operators/add_point_3d.py</code> <pre><code>class View3D_OT_slvs_add_point3d(Operator, Operator3d):\n    \"\"\"Add a point in 3d space\"\"\"\n\n    bl_idname = Operators.AddPoint3D\n    bl_label = \"Add Solvespace 3D Point\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    p3d_state1_doc = (\"Location\", \"Set point's location.\")\n\n    location: FloatVectorProperty(name=\"Location\", subtype=\"XYZ\", precision=5)\n\n    states = (\n        state_from_args(\n            p3d_state1_doc[0],\n            description=p3d_state1_doc[1],\n            property=\"location\",\n        ),\n    )\n\n    def main(self, context: Context):\n        self.target = context.scene.sketcher.entities.add_point_3d(self.location)\n        if context.scene.sketcher.use_construction:\n            self.target.construction = True\n\n        # Store hovered entity to use for auto-coincident since it doesn't get\n        # stored for non-interactive tools\n        hovered = global_data.hover\n        if self._check_constrain(context, hovered):\n            self.state_data[\"hovered\"] = hovered\n\n        self.add_coincident(context, self.target, self.state, self.state_data)\n        return True\n\n    def fini(self, context: Context, succeede: bool):\n        if hasattr(self, \"target\"):\n            logger.debug(\"Add: {}\".format(self.target))\n</code></pre> <p>               Bases: <code>Operator</code>, <code>Operator3d</code></p> <p>Add a line in 3d space</p> Source code in <code>operators/add_line_3d.py</code> <pre><code>class View3D_OT_slvs_add_line3d(Operator, Operator3d):\n    \"\"\"Add a line in 3d space\"\"\"\n\n    bl_idname = Operators.AddLine3D\n    bl_label = \"Add Solvespace 3D Line\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    l3d_state1_doc = (\"Startpoint\", \"Pick or place line's starting point.\")\n    l3d_state2_doc = (\"Endpoint\", \"Pick or place line's ending point.\")\n\n    continuous_draw: BoolProperty(name=\"Continuous Draw\", default=True)\n\n    states = (\n        state_from_args(\n            l3d_state1_doc[0],\n            description=l3d_state1_doc[1],\n            pointer=\"p1\",\n            types=types_point_3d,\n        ),\n        state_from_args(\n            l3d_state2_doc[0],\n            description=l3d_state2_doc[1],\n            pointer=\"p2\",\n            types=types_point_3d,\n            interactive=True,\n        ),\n    )\n\n    def main(self, context: Context):\n        p1, p2 = self.get_point(context, 0), self.get_point(context, 1)\n\n        self.target = context.scene.sketcher.entities.add_line_3d(p1, p2)\n        if context.scene.sketcher.use_construction:\n            self.target.construction = True\n        ignore_hover(self.target)\n        return True\n\n    def continue_draw(self):\n        last_state = self._state_data[1]\n        if last_state[\"is_existing_entity\"]:\n            return False\n\n        # also not when last state has coincident constraint\n        if last_state.get(\"coincident\"):\n            return False\n        return True\n\n    def fini(self, context: Context, succeede: bool):\n        if hasattr(self, \"target\"):\n            logger.debug(\"Add: {}\".format(self.target))\n\n        if succeede:\n            if self.has_coincident():\n                solve_system(context)\n</code></pre> <p>               Bases: <code>Operator</code>, <code>Operator2d</code></p> <p>Add a point to the active sketch</p> Source code in <code>operators/add_point_2d.py</code> <pre><code>class View3D_OT_slvs_add_point2d(Operator, Operator2d):\n    \"\"\"Add a point to the active sketch\"\"\"\n\n    bl_idname = Operators.AddPoint2D\n    bl_label = \"Add Solvespace 2D Point\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    p2d_state1_doc = (\"Coordinates\", \"Set point's coordinates on the sketch.\")\n\n    coordinates: FloatVectorProperty(name=\"Coordinates\", size=2, precision=5)\n\n    states = (\n        state_from_args(\n            p2d_state1_doc[0],\n            description=p2d_state1_doc[1],\n            property=\"coordinates\",\n        ),\n    )\n\n    def main(self, context: Context):\n        sketch = self.sketch\n        self.target = context.scene.sketcher.entities.add_point_2d(\n            self.coordinates, sketch\n        )\n        if context.scene.sketcher.use_construction:\n            self.target.construction = True\n\n        # Store hovered entity to use for auto-coincident since it doesn't get\n        # stored for non-interactive tools\n        hovered = global_data.hover\n        if self._check_constrain(context, hovered):\n            self.state_data[\"hovered\"] = hovered\n\n        self.add_coincident(context, self.target, self.state, self.state_data)\n        return True\n\n    def fini(self, context: Context, succeede: bool):\n        if hasattr(self, \"target\"):\n            logger.debug(\"Add: {}\".format(self.target))\n\n        if succeede:\n            if self.has_coincident():\n                solve_system(context, sketch=self.sketch)\n</code></pre> <p>               Bases: <code>Operator</code>, <code>Operator2d</code></p> <p>Add a line to the active sketch</p> Source code in <code>operators/add_line_2d.py</code> <pre><code>class View3D_OT_slvs_add_line2d(Operator, Operator2d):\n    \"\"\"Add a line to the active sketch\"\"\"\n\n    bl_idname = Operators.AddLine2D\n    bl_label = \"Add Solvespace 2D Line\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    l2d_state1_doc = (\"Startpoint\", \"Pick or place line's starting Point.\")\n    l2d_state2_doc = (\"Endpoint\", \"Pick or place line's ending Point.\")\n\n    continuous_draw: BoolProperty(name=\"Continuous Draw\", default=True)\n\n    states = (\n        state_from_args(\n            l2d_state1_doc[0],\n            description=l2d_state1_doc[1],\n            pointer=\"p1\",\n            types=types_point_2d,\n        ),\n        state_from_args(\n            l2d_state2_doc[0],\n            description=l2d_state2_doc[1],\n            pointer=\"p2\",\n            types=types_point_2d,\n            interactive=True,\n        ),\n    )\n\n    def main(self, context: Context):\n        wp = self.sketch.wp\n        p1, p2 = self.get_point(context, 0), self.get_point(context, 1)\n\n        self.target = context.scene.sketcher.entities.add_line_2d(p1, p2, self.sketch)\n        if context.scene.sketcher.use_construction:\n            self.target.construction = True\n\n        # auto vertical/horizontal constraint\n        self.has_alignment = False\n        constraints = context.scene.sketcher.constraints\n        vec_dir = self.target.direction_vec()\n        if vec_dir.length:\n            angle = vec_dir.angle(Vector((1, 0)))\n\n            threshold = 0.1\n            if angle &lt; threshold or angle &gt; HALF_TURN - threshold:\n                constraints.add_horizontal(self.target, sketch=self.sketch)\n                self.has_alignment = True\n            elif (QUARTER_TURN - threshold) &lt; angle &lt; (QUARTER_TURN + threshold):\n                constraints.add_vertical(self.target, sketch=self.sketch)\n                self.has_alignment = True\n\n        ignore_hover(self.target)\n        return True\n\n    def continue_draw(self):\n        last_state = self._state_data[1]\n        if last_state[\"is_existing_entity\"]:\n            return False\n\n        # also not when last state has coincident constraint\n        if last_state.get(\"coincident\"):\n            return False\n        return True\n\n    def fini(self, context: Context, succeede: bool):\n        if hasattr(self, \"target\"):\n            logger.debug(\"Add: {}\".format(self.target))\n\n        if succeede:\n            if self.has_coincident() or self.has_alignment:\n                solve_system(context, sketch=self.sketch)\n</code></pre> <p>               Bases: <code>Operator</code>, <code>Operator2d</code></p> <p>Add a circle to the active sketch</p> Source code in <code>operators/add_circle.py</code> <pre><code>class View3D_OT_slvs_add_circle2d(Operator, Operator2d):\n    \"\"\"Add a circle to the active sketch\"\"\"\n\n    bl_idname = Operators.AddCircle2D\n    bl_label = \"Add Solvespace 2D Circle\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    circle_state1_doc = (\"Center\", \"Pick or place circle's center point.\")\n    circle_state2_doc = (\"Radius\", \"Set circle's radius.\")\n\n    radius: FloatProperty(\n        name=\"Radius\",\n        subtype=\"DISTANCE\",\n        unit=\"LENGTH\",\n        precision=5,\n        # precision=get_prefs().decimal_precision,\n    )\n\n    states = (\n        state_from_args(\n            circle_state1_doc[0],\n            description=circle_state1_doc[1],\n            pointer=\"ct\",\n            types=types_point_2d,\n        ),\n        state_from_args(\n            circle_state2_doc[0],\n            description=circle_state2_doc[1],\n            property=\"radius\",\n            state_func=\"get_radius\",\n            interactive=True,\n            allow_prefill=False,\n        ),\n    )\n\n    def get_radius(self, context: Context, coords):\n        wp = self.sketch.wp\n        pos = get_pos_2d(context, wp, coords)\n        delta = Vector(pos) - self.ct.co\n        radius = delta.length\n        return radius\n\n    def main(self, context: Context):\n        wp = self.sketch.wp\n        ct = self.get_point(context, 0)\n        self.target = context.scene.sketcher.entities.add_circle(\n            wp.nm, ct, self.radius, self.sketch\n        )\n        if context.scene.sketcher.use_construction:\n            self.target.construction = True\n        ignore_hover(self.target)\n        return True\n\n    def fini(self, context: Context, succeede: bool):\n        if hasattr(self, \"target\"):\n            logger.debug(\"Add: {}\".format(self.target))\n\n        if succeede:\n            if self.has_coincident():\n                solve_system(context, sketch=self.sketch)\n</code></pre> <p>               Bases: <code>Operator</code>, <code>Operator2d</code></p> <p>Add an arc to the active sketch</p> Source code in <code>operators/add_arc.py</code> <pre><code>class View3D_OT_slvs_add_arc2d(Operator, Operator2d):\n    \"\"\"Add an arc to the active sketch\"\"\"\n\n    bl_idname = Operators.AddArc2D\n    bl_label = \"Add Solvespace 2D Arc\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    arc_state1_doc = (\"Center\", \"Pick or place center point.\")\n    arc_state2_doc = (\"Startpoint\", \"Pick or place starting point.\")\n    arc_state3_doc = (\"Endpoint\", \"Pick or place ending point.\")\n\n    states = (\n        state_from_args(\n            arc_state1_doc[0],\n            description=arc_state1_doc[1],\n            pointer=\"ct\",\n            types=types_point_2d,\n        ),\n        state_from_args(\n            arc_state2_doc[0],\n            description=arc_state2_doc[1],\n            pointer=\"p1\",\n            types=types_point_2d,\n            allow_prefill=False,\n        ),\n        state_from_args(\n            arc_state3_doc[0],\n            description=arc_state3_doc[1],\n            pointer=\"p2\",\n            types=types_point_2d,\n            state_func=\"get_endpoint_pos\",\n            interactive=True,\n        ),\n    )\n\n    def get_endpoint_pos(self, context: Context, coords):\n        mouse_pos = get_pos_2d(context, self.sketch.wp, coords)\n        if mouse_pos is None:\n            return None\n\n        # Get angle to mouse pos\n        ct = self.get_point(context, 0).co\n        x, y = Vector(mouse_pos) - ct\n        angle = math.atan2(y, x)\n\n        # Get radius from distance ct - p1\n        p1 = self.get_point(context, 1).co\n        radius = (p1 - ct).length\n        pos = pol2cart(radius, angle) + ct\n        return pos\n\n    def solve_state(self, context: Context, _event: Event):\n        sketch = context.scene.sketcher.active_sketch\n        solve_system(context, sketch=sketch)\n        return True\n\n    def main(self, context):\n        ct, p1, p2 = (\n            self.get_point(context, 0),\n            self.get_point(context, 1),\n            self.get_point(context, 2),\n        )\n        sketch = self.sketch\n        sse = context.scene.sketcher.entities\n        arc = sse.add_arc(sketch.wp.nm, ct, p1, p2, sketch)\n\n        center = ct.co\n        start = p1.co - center\n        end = p2.co - center\n        a = end.angle_signed(start)\n        arc.invert_direction = a &lt; 0\n\n        ignore_hover(arc)\n        self.target = arc\n        if context.scene.sketcher.use_construction:\n            self.target.construction = True\n        return True\n\n    def fini(self, context: Context, succeede: bool):\n        if hasattr(self, \"target\"):\n            logger.debug(\"Add: {}\".format(self.target))\n            self.solve_state(context, self.sketch)\n</code></pre> <p>               Bases: <code>Operator</code>, <code>Operator2d</code></p> <p>Add a rectangle to the active sketch</p> Source code in <code>operators/add_rectangle.py</code> <pre><code>class View3D_OT_slvs_add_rectangle(Operator, Operator2d):\n    \"\"\"Add a rectangle to the active sketch\"\"\"\n\n    bl_idname = Operators.AddRectangle\n    bl_label = \"Add Rectangle\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    rect_state1_doc = (\"Startpoint\", \"Pick or place starting point.\")\n    rect_state2_doc = (\"Endpoint\", \"Pick or place ending point.\")\n\n    states = (\n        state_from_args(\n            rect_state1_doc[0],\n            description=rect_state1_doc[1],\n            pointer=\"p1\",\n            types=types_point_2d,\n        ),\n        state_from_args(\n            rect_state2_doc[0],\n            description=rect_state2_doc[1],\n            pointer=\"p2\",\n            types=types_point_2d,\n            interactive=True,\n            create_element=\"create_point\",\n        ),\n    )\n\n    def main(self, context: Context):\n        sketch = self.sketch\n        sse = context.scene.sketcher.entities\n\n        p1, p2 = self.get_point(context, 0), self.get_point(context, 1)\n        p_lb, p_rt = p1, p2\n\n        p_rb = sse.add_point_2d((p_rt.co.x, p_lb.co.y), sketch)\n        p_lt = sse.add_point_2d((p_lb.co.x, p_rt.co.y), sketch)\n\n        if context.scene.sketcher.use_construction:\n            p_lb.construction = True\n            p_rb.construction = True\n            p_rt.construction = True\n            p_lt.construction = True\n\n        lines = []\n        points = (p_lb, p_rb, p_rt, p_lt)\n        for i, start in enumerate(points):\n            end = points[i + 1 if i &lt; len(points) - 1 else 0]\n\n            line = sse.add_line_2d(start, end, sketch)\n            if context.scene.sketcher.use_construction:\n                line.construction = True\n            lines.append(line)\n\n        self.lines = lines\n\n        for e in (*points, *lines):\n            ignore_hover(e)\n        return True\n\n    def fini(self, context: Context, succeede: bool):\n        if hasattr(self, \"lines\") and self.lines:\n            ssc = context.scene.sketcher.constraints\n            for i, line in enumerate(self.lines):\n                func = ssc.add_horizontal if (i % 2) == 0 else ssc.add_vertical\n                func(line, sketch=self.sketch)\n\n            data = self._state_data.get(1)\n            if data.get(\"is_numeric_edit\", False):\n                input = data.get(\"numeric_input\")\n\n                # constrain distance\n                startpoint = getattr(self, self.get_states()[0].pointer)\n                for val, line in zip(input, (self.lines[1], self.lines[2])):\n                    if val is None:\n                        continue\n                    ssc.add_distance(\n                        startpoint,\n                        line,\n                        sketch=self.sketch,\n                        init=True,\n                    )\n\n        if succeede:\n            if self.has_coincident():\n                solve_system(context, sketch=self.sketch)\n\n    def create_point(self, context: Context, values, state, state_data):\n        value = values[0]\n\n        if state_data.get(\"is_numeric_edit\", False):\n            data = self._state_data.get(1)\n            input = data.get(\"numeric_input\")\n            # use relative coordinates\n            orig = getattr(self, self.get_states()[0].pointer).co\n\n            for i, val in enumerate(input):\n                if val is None:\n                    continue\n                value[i] = orig[i] + val\n\n        sse = context.scene.sketcher.entities\n        point = sse.add_point_2d(value, self.sketch)\n        ignore_hover(point)\n        if context.scene.sketcher.use_construction:\n            point.construction = True\n\n        self.add_coincident(context, point, state, state_data)\n        state_data[\"type\"] = SlvsPoint2D\n        return point.slvs_index\n</code></pre> <p>               Bases: <code>Operator</code>, <code>Operator3d</code></p> <p>Add a workplane</p> Source code in <code>operators/add_workplane.py</code> <pre><code>class View3D_OT_slvs_add_workplane(Operator, Operator3d):\n    \"\"\"Add a workplane\"\"\"\n\n    bl_idname = Operators.AddWorkPlane\n    bl_label = \"Add Solvespace Workplane\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    wp_state1_doc = (\"Origin\", \"Pick or place workplanes's origin.\")\n    wp_state2_doc = (\"Orientation\", \"Set workplane's orientation.\")\n\n    states = (\n        state_from_args(\n            wp_state1_doc[0],\n            description=wp_state1_doc[1],\n            pointer=\"p1\",\n            types=types_point_3d,\n        ),\n        state_from_args(\n            wp_state2_doc[0],\n            description=wp_state2_doc[1],\n            state_func=\"get_orientation\",\n            pointer=\"nm\",\n            types=NORMAL3D,\n            interactive=True,\n            create_element=\"create_normal3d\",\n        ),\n    )\n\n    def get_normal(self, context: Context, index: int):\n        states = self.get_states_definition()\n        state = states[index]\n        data = self._state_data[index]\n        type = data[\"type\"]\n        sse = context.scene.sketcher.entities\n\n        if type == bpy.types.MeshPolygon:\n            ob_name, nm_index = self.get_state_pointer(index=index, implicit=True)\n            ob = bpy.data.objects[ob_name]\n            return sse.add_ref_normal_3d(ob, nm_index)\n        return getattr(self, state.pointer)\n\n    def get_orientation(self, context: Context, coords):\n        # TODO: also support edges\n        data = self.state_data\n        ob, type, index = get_mesh_element(context, coords, edge=False, face=True)\n\n        p1 = self.get_point(context, 0)\n        mousepos = get_placement_pos(context, coords)\n        vec = mousepos - p1.location\n        return global_data.Z_AXIS.rotation_difference(vec).to_euler()\n\n    def create_normal3d(self, context: Context, values, state, state_data):\n        sse = context.scene.sketcher.entities\n\n        v = values[0].to_quaternion()\n        nm = sse.add_normal_3d(v)\n        state_data[\"type\"] = SlvsNormal3D\n        return nm.slvs_index\n\n    def main(self, context: Context):\n        sse = context.scene.sketcher.entities\n        p1 = self.get_point(context, 0)\n        nm = self.get_normal(context, 1)\n        self.target = sse.add_workplane(p1, nm)\n        ignore_hover(self.target)\n        return True\n\n    def fini(self, context: Context, succeede: bool):\n        if hasattr(self, \"target\"):\n            logger.debug(\"Add: {}\".format(self.target))\n\n        if succeede:\n            if self.has_coincident():\n                solve_system(context)\n</code></pre> <p>               Bases: <code>Operator</code>, <code>Operator3d</code></p> <p>Add a statically placed workplane, orientation and location is copied from selected mesh face</p> Source code in <code>operators/add_workplane.py</code> <pre><code>class View3D_OT_slvs_add_workplane_face(Operator, Operator3d):\n    \"\"\"Add a statically placed workplane, orientation and location is copied from selected mesh face\"\"\"\n\n    bl_idname = Operators.AddWorkPlaneFace\n    bl_label = \"Add Solvespace Workplane\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    wp_face_state1_doc = (\n        \"Face\",\n        \"Pick a mesh face to use as workplanes's transformation.\",\n    )\n\n    states = (\n        state_from_args(\n            wp_face_state1_doc[0],\n            description=wp_face_state1_doc[1],\n            use_create=False,\n            pointer=\"face\",\n            types=(bpy.types.MeshPolygon,),\n            interactive=True,\n        ),\n    )\n\n    def main(self, context: Context):\n        sse = context.scene.sketcher.entities\n\n        ob_name, face_index = self.get_state_pointer(index=0, implicit=True)\n        ob = get_evaluated_obj(context, bpy.data.objects[ob_name])\n        mesh = ob.data\n        face = mesh.polygons[face_index]\n\n        mat_obj = ob.matrix_world\n        quat = get_face_orientation(mesh, face)\n        quat.rotate(mat_obj)\n        pos = mat_obj @ face.center\n        origin = sse.add_point_3d(pos)\n        nm = sse.add_normal_3d(quat)\n\n        self.target = sse.add_workplane(origin, nm)\n        ignore_hover(self.target)\n        context.area.tag_redraw() # Force re-draw of UI (Blender doesn't update after tool usage)\n        return True\n</code></pre> <p>               Bases: <code>Operator</code>, <code>Operator2d</code></p> <p>Trim segment to its closest intersections</p> Source code in <code>operators/trim.py</code> <pre><code>class View3D_OT_slvs_trim(Operator, Operator2d):\n    \"\"\"Trim segment to its closest intersections\"\"\"\n\n    bl_idname = Operators.Trim\n    bl_label = \"Trim Segment\"\n    bl_options = {\"REGISTER\", \"UNDO\"}\n\n    trim_state1_doc = (\"Segment\", \"Segment to trim.\")\n\n    states = (\n        state_from_args(\n            trim_state1_doc[0],\n            description=trim_state1_doc[1],\n            pointer=\"segment\",\n            types=SEGMENT,\n            pick_element=\"pick_element_coords\",\n            use_create=False,\n            # interactive=True\n        ),\n    )\n\n    # TODO: Disable execution based on selection\n    # NOTE: That does not work if run with select -&gt; action\n    def pick_element_coords(self, context, coords):\n        data = self.state_data\n        data[\"mouse_pos\"] = get_pos_2d(context, self.sketch.wp, coords)\n        return super().pick_element(context, coords)\n\n    def main(self, context: Context):\n        return True\n\n    def fini(self, context: Context, succeede: bool):\n        if not succeede:\n            return False\n\n        sketch = context.scene.sketcher.active_sketch\n        segment = self.segment\n\n        mouse_pos = self._state_data[0].get(\"mouse_pos\")\n        if mouse_pos is None:\n            return False\n\n        trim = TrimSegment(segment, mouse_pos)\n\n        # Find intersections\n        for e in sketch.sketch_entities(context):\n            if not e.is_segment():\n                continue\n            if e == segment:\n                continue\n\n            for co in segment.intersect(e):\n                # print(\"intersect\", co)\n                trim.add(e, co)\n\n        # Find points that are connected to the segment through a coincident constraint\n        for c in (\n            *context.scene.sketcher.constraints.coincident,\n            *context.scene.sketcher.constraints.midpoint,\n        ):\n            ents = c.entities()\n            if segment not in ents:\n                continue\n            p = ents[0]\n            trim.add(c, p.co)\n\n        # TODO: Get rid of the coincident constraint as it will be a shared connection point\n\n        if not trim.check():\n            return\n\n        trim.replace(context)\n        refresh(context)\n</code></pre>"},{"location":"user_interface/","title":"User interface","text":""},{"location":"user_interface/#sidebar","title":"Sidebar","text":"<p>The extension adds a some panels to the \"N\"-sidebar under the category \"Sketcher\". From here you can set the active sketch, access its properties, add constraints and interact with elements via the browsers.</p>"},{"location":"user_interface/#sketch-selector","title":"Sketch Selector","text":"<p>Whenever no sketch is active the sidebar will list all available sketches. From there you can toggle the visibility of the sketches or set one as active. The UI will change when a sketch is active, showing a big blue button which lets you exit the sketch as well as some properties of that sketch.</p>"},{"location":"user_interface/#entity-browser","title":"Entity Browser","text":"<p>Lists all currently active entities. Allows selection by clicking on the name.</p>"},{"location":"user_interface/#constraint-browser","title":"Constraint Browser","text":"<p>Lists all currently active constraints. Shows the failure state on the left and allows to invoke the constraint's context menu.</p>"},{"location":"user_interface/#gizmos","title":"Gizmos","text":"<p>Gizmos are used to display constraints. There are specific gizmo types for the three dimensional constraints, angle, distance and diameter.</p> <p>To interact with the settings of a constraint click its gizmo to open a menu.  </p> <p>The rest of the constraints use a generic gizmo that is displayed next to the entities they depend on. Clicking such a gizmo either shows the constraint's settings or directly deletes the constraint if it has no settings to show.</p>"},{"location":"user_interface/#context-menu","title":"Context Menu","text":"<p>The context menu can be used to access properties and actions of an element, either by hovering an entity and pressing the right mouse button, by clicking a constraint gizmo that supports it or through the corresponding button in one of the element browsers.</p> <p>INFO: Only the hovered entity is used, the context menu ignores the selection.</p>"},{"location":"user_interface/#preferences","title":"Preferences","text":"<p>Access the preferences by expanding the enabled extension under Edit &gt; Preferences &gt; Add-ons &gt; CAD Sketcher.</p> <p> </p>"},{"location":"user_interface/#solver-module","title":"Solver Module","text":"<p>Shows either the path to the registered solver module or options to install it.</p>"},{"location":"user_interface/#general","title":"General","text":"<ul> <li>By enabling \"Show Debug Settings\" some experimental features are enabled, use with caution.</li> <li>Choose the logging settings</li> </ul>"},{"location":"user_interface/#theme","title":"Theme","text":"<p>Colors that are used in the extension are defined under the theme section. The extension also supports theme presets. You can get the presets path by entering the following line into blenders python console:</p> <pre><code>bpy.utils.user_resource(\"SCRIPTS\")\n</code></pre>"}]}